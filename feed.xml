<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>FX</title>
    <link href="https://scooorpion.github.io/feed.xml" rel="self" />
    <link href="https://scooorpion.github.io" />
    <updated>2024-07-27T00:36:37+08:00</updated>
    <author>
        <name>scooorpion</name>
    </author>
    <id>https://scooorpion.github.io</id>

    <entry>
        <title>Why We Sleep</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/why-we-sleep.html"/>
        <id>https://scooorpion.github.io/why-we-sleep.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/24/google-deepmind-GVGnKgEomlw-unsplash.jpg" medium="image" />

        <updated>2024-07-27T00:33:58+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/24/google-deepmind-GVGnKgEomlw-unsplash.jpg" alt="" />
                    斯坦福医学院神经学教授Andrew Huberman有个很红的播客叫Huberman Lab,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/24/google-deepmind-GVGnKgEomlw-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                
  <p>
    <br><br>斯坦福医学院神经学教授Andrew Huberman有个很红的播客叫Huberman Lab, 他请过几个当红睡眠科学家包括写Why We Sleep的Matthew Walker上他的节目。 如果你每天都是同一个时间入睡，入睡前90分钟，大脑神经元会同步收缩和扩张，这样就会形成一个泵，把大脑里的废物和毒素泵出来。
  </p>

  <p>
    如果你每天都是11点水，忽然有一天2点才睡，那这个泵垃圾的过程就会大部分被跳过，进入后面REM比较多的阶段。
  </p>

  <p>
    如果哪天你只睡了四个小时，大脑中的淀粉样蛋白就会增多。它不会让你一夜得痴呆症，但是常年累月就不一定了。
  </p>

  <p>
    Andrew Huberman有个著名的Huberman Routine，可以白天提升注意力和精力，晚上提升睡眠质量。很多人试过，好评如潮，都说工作学习的产出明显提升，睡得也更好了。我已经用了半年多，拯救了我的睡眠和工作。大家可以上B站上搜Huberman Lab关于睡眠工具的那集。高赞有卖补剂的。但是Huberman推荐的干预工具头一个是行为改变，不管用以后才用补剂。
  </p>

  <p>
    Huberman Routine大概是这样的，具体原理请看他的视频:
  </p>

  <p>
    每天同一时间醒来，而且是在太阳高升以前醒来。喝一大杯电解质水，尽早出门看靠近地平线的黄黄的太阳，视亮度看5-30分钟，你的眼睛需要足够的光子才能给神经系统传递够强的信号。太阳光的角度和颜色很重要。这个行为可以固定人的生物钟。
  </p>

  <p>
    醒来60分钟以内不要进食，90分钟以内不要进咖啡因。睡前三个小时不要进食。
  </p>

  <p>
    工作或学习以前冷水浴3-10分钟可以让多巴胺提升两倍，在接下来的两三个小时让头脑清醒，平静，容易集中注意力。对多巴胺的提升效果堪比可卡因。
  </p>

  <p>
    白天除非运动否则不吃升血糖的碳水，维持精力。
  </p>

  <p>
    中午小睡或者用瑜伽休息术/非睡眠深度休息放松，网上有很多音频。然后迎来一天中第二个大脑高效运行的两小时。
  </p>

  <p>
    晚餐包含碳水增加血清素的分泌方便入眠。
  </p>

  <p>
    日落前看太阳，可以减轻夜晚人造光对睡眠的干扰。
  </p>

  <p>
    睡前用热水澡帮助降低核心体温。
  </p>

  <p>
    日落后保持室内光线昏暗，最好用红光，避免头顶灯，用比视线低的台灯以减小睡眠干扰。不玩手机电脑，最好看书或者做点别的喜欢的事。
  </p>

  <p>
    可以用瑜伽休息术或者NSDR帮助入眠，或者半夜醒来之后重新入眠。每晚同一时间入眠。就算是自认为是夜猫子的人其实早点睡表现更好。一般11点左右睡最好。
  </p>

  <p>
    若干睡眠补剂比如甘氨酸镁/苏糖酸镁，茶氨酸。不要用褪黑素。睡眠界红人Mathew Walker说了，完全不管用。还没有睡前两个猕猴桃管用。
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>浪费时间本身就是一种利用时间的方式</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/lang-fei-shi-jian-ben-shen-jiu-shi-li-yong-shi-jian-de-fang-shi.html"/>
        <id>https://scooorpion.github.io/lang-fei-shi-jian-ben-shen-jiu-shi-li-yong-shi-jian-de-fang-shi.html</id>

        <updated>2024-07-27T00:29:52+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                
  <p>
    
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>决定论、自指以及其它</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/jue-ding-lunzi-zhi-yi-ji-qi-ta.html"/>
        <id>https://scooorpion.github.io/jue-ding-lunzi-zhi-yi-ji-qi-ta.html</id>

        <updated>2024-07-22T23:43:06+08:00</updated>
            <summary>
                <![CDATA[
                    我有个类似自指的一个话题，如果世界上真正这个宇宙中真的有一个造物者，真的有个神，可以是上帝，还可以是什么，就是普世意义上的一个神，那么我们的所作所为全部都是由这个神他来这个操控和和指引。科学上来讲我们是符合决定论、宿命论，就是所有的事情其实都是规规定好的，就是因为所有的下一件事情其实都可以用上一件事情来计算出来，如果计算不出来，只是因为我们的算力不够多，那所谓的量子力学，这个量子力学它也是被薛定谔方程确定的，所以怎么个再不确定的东西，它都是被一个东西给确定的，只是说我们以人类的视角来看，我们算不出来这个东西，那么回到这个问题，那有没有一种这个造物者或者一种超自然力量在指引着这一切发生，在指引着这世界上的一切事情，每隔 1 秒下&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                
    <blockquote class="blockquote">
      我有个类似自指的一个话题，如果世界上真正这个宇宙中真的有一个造物者，真的有个神，可以是上帝，还可以是什么，就是普世意义上的一个神，那么我们的所作所为全部都是由这个神他来这个操控和和指引。科学上来讲我们是符合决定论、宿命论，就是所有的事情其实都是规规定好的，就是因为所有的下一件事情其实都可以用上一件事情来计算出来，如果计算不出来，只是因为我们的算力不够多，那所谓的量子力学，这个量子力学它也是被薛定谔方程确定的，所以怎么个再不确定的东西，它都是被一个东西给确定的，只是说我们以人类的视角来看，我们算不出来这个东西，那么回到这个问题，那有没有一种这个造物者或者一种超自然力量在指引着这一切发生，在指引着这世界上的一切事情，每隔 1 秒下 1 秒的事情该怎么样走向？那么我现在的这个想法是不是也是由这个超自然现象来指引的，也就是说我产生了对这个超自然现象怀疑的这个想法，也是超自然现象来来操控我产生的。这是一个不停的自指一样的感觉，感觉在不停的逻辑循环，陷入死循环，有一种数学中或者计算机中的递归，但是没有条件限制的递归下去。
    </blockquote>

  <p>
    
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Planning fallacy 计划谬误</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/planning-fallacy-ji-hua-miu-wu.html"/>
        <id>https://scooorpion.github.io/planning-fallacy-ji-hua-miu-wu.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/21/google-deepmind-McOWBCaY0eg-unsplash.jpg" medium="image" />
            <category term="Book report"/>

        <updated>2024-07-21T00:32:19+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/21/google-deepmind-McOWBCaY0eg-unsplash.jpg" alt="" />
                    计划谬误（Planning Fallacy）是指人们在估计未来任务的完成时间时，倾向于过度乐观，低估任务完成时间的一种现象。这种现象的主要原因包括认知偏差、动机因素以及个体的经验水平等。为了有效解决计划谬误的问题，可以采取以下几种方法： 帕金森定律（Parkinson’s&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/21/google-deepmind-McOWBCaY0eg-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>计划谬误（Planning Fallacy）是指人们在估计未来任务的完成时间时，倾向于过度乐观，低估任务完成时间的一种现象。这种现象的主要原因包括认知偏差、动机因素以及个体的经验水平等。为了有效解决计划谬误的问题，可以采取以下几种方法：</p><ol>
<li><strong>使用历史数据</strong>：通过参考过去类似任务的实际完成时间和预算，可以更准确地预测当前任务的所需时间。</li>
<li><strong>增强风险意识</strong>：充分考虑潜在的问题和延误，并为任务预留足够的时间。</li>
<li><strong>从第三人称视角进行估计</strong>：以旁观者的角度审视自己的计划，避免因主观情绪影响判断。</li>
<li><strong>任务分解及时间分配</strong>：将大任务拆分为小任务，并对每个小任务进行详细的时间规划和监控。</li>
</ol>
<p>帕金森定律（Parkinson’s Law）由英国历史学家诺斯古德·帕金森提出，指出“工作总是会填满为它预留的时间”。该定律解释了为什么有时一个本来只需三小时的任务，却会拖到八小时甚至更长。其核心思想是，如果给定的时间过多，团队可能会放慢工作进度，使得工作刚好填满预留的时间。</p><p>类似的定律还有：</p><ol>
<li><strong>墨菲定律（Murphy’s Law）</strong>：任何可能出错的事都会出错。它强调了事情变坏的可能性及其对组织的影响。</li>
<li><strong>彼得原理（Peter’s Principle）</strong>：在组织中，每个员工最终都会被提升到他无法胜任的职位上。这导致效率低下和资源浪费。</li>
<li><strong>海恩法则（Heinrich’s Law）</strong>：事故的发生往往是量变积累的结果，小的疏忽可能导致严重的后果。</li>
</ol>
<p>这些定律共同揭示了组织中常见的问题和规律，帮助管理者更好地理解并应对这些问题，从而提高组织效率和绩效。</p><p>总结来说，计划谬误和帕金森定律都反映了人类在时间和资源管理上的普遍挑战。通过科学预估时间、增强风险意识、合理分配任务和时间等策略，可以有效减少计划谬误带来的负面影响。同时，了解并应用其他相关管理学定律，如墨菲定律和彼得原理，可以帮助我们更全面地理解和解决组织中的各种问题。</p><h4 id="如何准确测量和预测项目完成时间以避免计划谬误？">如何准确测量和预测项目完成时间以避免计划谬误？</h4>
<p>要准确测量和预测项目完成时间以避免计划谬误，可以采取以下几种方法：</p><ol>
<li><p><strong>使用专家判断</strong>：这是最常用的方法之一。通过依赖具有丰富经验的专家，他们可以根据以往的项目经验和当前项目的具体情况，给出较为准确的时间估计。</p></li>
<li><p><strong>类比估算法</strong>：这种方法通过比较类似项目的实际耗时来估算当前项目的任务时间。</p></li>
<li><p><strong>参数估算法</strong>：利用历史数据和项目特征，使用回归算法（如线性回归、支持向量机回归等）来预测项目任务的执行时间。</p></li>
<li><p><strong>三点估算法</strong>：这种方法结合了最乐观时间、最可能时间和最悲观时间的估计，从而提供一个更全面的时间范围。</p></li>
<li><p><strong>德尔菲法</strong>：通过多次征询专家意见，并在每次征询后对意见进行汇总和反馈，最终达成一致的预测结果。</p></li>
<li><p><strong>关键路径法</strong>：通过识别项目的关键路径来预测整个项目的持续时间。这种方法可以通过工作分解结构（WBS）将大任务拆分成更小的活动，然后将这些小活动安排在合适的时间内完成。</p></li>
<li><p><strong>引入缓冲时间</strong>：在时间估算中引入一定的缓冲时间，以应对不可预见的风险和不确定性。</p></li>
<li><p><strong>持续评估和调整</strong>：在项目进行过程中，持续评估和调整时间计划，以确保项目能够按计划进行。</p></li>
<li><p><strong>详尽需求分析</strong>：确保准确估计的基础是详尽的需求分析。这要求与利益相关者紧密合作，彻底理解项目的范围和复杂度。</p></li>
</ol>
<h4 id="帕金森定律在不同行业中的应用案例有哪些？">帕金森定律在不同行业中的应用案例有哪些？</h4>
<p>帕金森定律在不同行业中的应用案例非常广泛，以下是一些具体的例子：</p><p>   在软件开发中，帕金森定律常常表现为项目工期的延长。例如，一个软件开发团队接手了一个前所未有的复杂项目，由于缺乏明确的定义和计划，导致项目不断延期。为了避免这种情况，工程师团队需要合理分解任务，并避免过度依赖可用的时间。</p><p>   帕金森定律在计算机操作系统、数据库管理系统和编译器设计等领域也有重要应用。通过合理的设计和优化，可以提高系统的性能和可靠性。</p><p>   在企业中，帕金森定律的应用主要体现在会议、预算编制和工作计划等方面。例如，某些企业可能会出现不必要的会议和冗长的工作流程，从而降低工作效率。因此，企业需要去除不必要的环节和任务，以提高工作的效率和质量。</p><p>   在行政管理中，帕金森定律表现为机构人员的膨胀。例如，在渭南市文化局管理网吧的过程中，只有8人编制却有54人上班，领工资的近70人。这种现象说明了机构人员膨胀的原因及后果。</p><p>这些案例表明，帕金森定律不仅揭示了官僚主义体制中的问题，还帮助个人和组织更好地理解和利用有限的资源，实现更好的绩效和效益。</p><h4 id="墨菲定律和彼得原理在实际管理中如何有效实施？">墨菲定律和彼得原理在实际管理中如何有效实施？</h4>
<p>在实际管理中，墨菲定律和彼得原理可以有效地指导管理者进行项目管理和组织优化。以下是具体实施方法：</p><h3 id="墨菲定律的实施">墨菲定律的实施</h3>
<p>   墨菲定律提醒管理者要时刻关注潜在问题和风险点。因此，在项目管理中，首先需要进行详细的风险评估，识别可能的不确定因素，并制定相应的应对策略。</p><p>   在项目执行过程中，持续的监控和控制是必不可少的。通过定期的项目进度检查和质量控制，及时发现并解决潜在问题。同时，项目结束后应进行总结反馈，分析项目中的成功经验和失败教训，以便为未来的项目提供参考。</p><p>   根据实际情况的变化，灵活调整项目计划。这包括对资源、时间表和预算的重新分配，以确保项目能够顺利进行。</p><p>   墨菲定律还强调了团队成员之间的沟通和协作的重要性。通过有效的沟通机制，确保每个成员都了解项目的最新动态和自己的职责，从而提高整体工作效率和创新能力。</p><h3 id="彼得原理的实施">彼得原理的实施</h3>
<p>   彼得原理指出，人们往往会被晋升到他们无法胜任的职位。因此，组织应当在招聘和晋升时，注重个人的能力与岗位需求的匹配度。将合适的人放在合适的岗位上，让每个人都能发挥出最大的价值。</p><p>   为了防止组织臃肿，彼得原理提倡减少不必要的人员。通过精简机构和优化人员配置，确保每个岗位都有明确的职责和高效的执行能力。</p><p>   单纯依据贡献决定晋升的机制容易导致“彼得效应”。因此，组织应建立更为科学的评价体系，考虑员工的综合素质、潜力和发展前景，而不是仅仅基于当前的表现或职位。</p><p>   通过大量的实践案例和模型设计，如“学习项目设计七步模型”，可以帮助管理者更好地理解和应用彼得原理。这些案例和模型提供了具体的实施步骤和方法论，有助于在实际操作中避免常见的陷阱。</p><h4 id="海恩法则与其他管理学定律相比，其优势和局限性是什么？">海恩法则与其他管理学定律相比，其优势和局限性是什么？</h4>
<p>海恩法则（Heinrich’s Law）是一种在工业和组织管理领域广泛应用的法则，最早由德国帕布斯·海恩提出，主要用于航空安全管理中。该法则指出，在任何一个组织或系统中，小问题和事故都是可以预防的。</p><h3 id="优势">优势</h3>
<ol>
<li><strong>预防为主</strong>：海恩法则强调通过识别和解决小问题来预防大事故的发生，从而提高整体安全性和稳定性。</li>
<li><strong>程序化管理</strong>：任何生产过程都要进行程序化管理，这样使整个生产过程都可以进行考量，这是发现事故征兆的前提。</li>
<li><strong>责任明确</strong>：对每一个程序都要划分相应的责任，可以找到相应的负责人，让他们认识到安全生产的重要性以及安全事故带来的巨大危害性。</li>
<li><strong>实际效果显著</strong>：在手术室护理管理中的应用表明，海恩法则能够显著降低不良事件发生率，并提高护理质量和患者满意度。</li>
<li><strong>广泛适用性</strong>：除了航空安全领域，海恩法则还被应用于其他多个行业如银行培训管理和保密工作等，显示出其广泛的适用性和有效性。</li>
</ol>
<h3 id="局限性">局限性</h3>
<ol>
<li><strong>适用范围有限</strong>：尽管海恩法则在多个领域得到了应用，但其适用范围仍较为局限，特别是在一些特定的复杂环境中可能难以完全实施。</li>
<li><strong>依赖于初期识别</strong>：海恩法则的成功实施需要在早期阶段就进行有效的风险识别和管理，这要求组织具备较高的风险意识和管理能力。</li>
<li><strong>实施成本高</strong>：在某些情况下，特别是涉及到技术先进、监管有力的信息防护体系时，构建和维护这些系统可能需要较高的成本投入。</li>
</ol>
<h4 id="如何结合使用多种管理学定律来提高组织效率和绩效？">如何结合使用多种管理学定律来提高组织效率和绩效？</h4>
<p>要提高组织效率和绩效，可以结合使用多种管理学定律和策略。以下是一些具体的建议：</p><ol>
<li><p><strong>优化治理结构和流程</strong>：通过优化组织的治理结构和流程，可以提高决策效率和执行力，并建立透明度和责任制度，从而有效提升组织绩效。</p></li>
<li><p><strong>设定明确目标</strong>：在绩效管理过程中，首要的一步是设定明确的目标。这些目标应具有可量化性，并且能够分解和分配到各个部门和个人，以便更好地规划和管理资源。</p></li>
<li><p><strong>建立反馈机制</strong>：有效的反馈机制可以帮助员工及时了解自己的工作表现，并进行相应的调整和改进。这种机制不仅有助于提高员工的工作质量，还能增强他们的工作动力。</p></li>
<li><p><strong>激励机制</strong>：设计科学的激励机制，包括奖励和惩罚措施，可以激发员工的工作动力和潜能。通过合理的激励措施，可以显著提高员工的工作积极性和绩效。</p></li>
<li><p><strong>持续改进</strong>：通过不断评估和改进绩效管理体系，可以确保其始终处于最佳状态。这包括定期回顾和调整绩效评价标准、指标以及激励机制，以适应组织的发展需求。</p></li>
<li><p><strong>培训与发展</strong>：注重员工的培训和发展，不断提升他们的能力和技能，是提高整体绩效的重要手段。通过系统的培训计划，可以帮助员工掌握新的知识和技能，从而更好地完成工作任务。</p></li>
<li><p><strong>信息技术支持</strong>：利用现代信息技术手段，如绩效管理系统（PMS），可以更高效地进行绩效评估和管理。这些系统可以提供实时数据和分析报告，帮助管理者做出更准确的决策。</p></li>
</ol>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Swift Notes</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/swift-notes.html"/>
        <id>https://scooorpion.github.io/swift-notes.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/20/google-deepmind-RO_I_35SX7c-unsplash.jpg" medium="image" />
            <category term="Swift"/>

        <updated>2024-07-16T20:51:45+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/20/google-deepmind-RO_I_35SX7c-unsplash.jpg" alt="" />
                    Basic 打印常量和变量 Printing&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/20/google-deepmind-RO_I_35SX7c-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <h2 id="basic">Basic</h2>
<h3 id="打印常量和变量-printing-constants-and-variables">打印常量和变量 <em>Printing Constants and Variables</em></h3>
<p><code>print(_:separator:terminator:)</code></p><ul>
<li><code>separator</code> : 用于分隔</li>
<li><code>terminator</code> : 用于结尾</li>
<li>字符串插值（string interpolation）：<code>&quot;\(value)&quot;</code></li>
</ul>
<h3 id="decimal">Decimal</h3>
<ul>
<li><p>四则运算一定要同类型，否则会造成精度缺失或者一些更严重的问题。</p></li>
<li><p>0.1 + 0.2 != 0.3</p><p>计算机内部使用二进制来表示浮点数，而二进制无法精确表示十进制的小数点后无限位的数值。 具体来说，十进制小数 <code>0.1</code> 在二进制中是一个无限循环小数。二进制中没有直接的表示方法来精确表示 <code>0.1</code>，因此计算机使用最接近的浮点数表示来近似它。同样，<code>0.2</code> 也是一个无法精确表示的十进制小数，在二进制中有类似的近似问题。 当你把两个这样的近似值相加时，结果会受到这种近似的影响，产生一个稍微大于 <code>0.3</code> 的值。这是浮点数精度问题的一个常见例子，也是为什么在涉及浮点数的比较时，经常需要设置一个误差范围（或者使用特定的数学库来处理高精度的小数运算）。</p><p> 在Swift中，你可以使用 <code>Double</code> 类型来进行浮点数运算，但是由于其内部表示的限制，你可能会遇到这种精度问题。如果你需要更精确的小数运算，可以考虑使用 <code>Decimal</code> 类型，它提供了更高的精度，但相应的也会消耗更多的内存和计算资源。</p></li>
</ul>
<p><code>Decimal</code> 需要 <strong>Foundation</strong> Framework，是一个可选类型（Optional）,你不能保证这个数字一定能转化成功</p><pre><code class="language-swift">import Foundation

import Foundation 
let decimal: Decimal = 1 
let decimal2 = Decimal（1）
let decimal3: Decimal = 3.24 //这个写法是有问题的，因为相当于在Decimal中存了一个Double
print（decima13）//3.2400000000003

let decimal4 = Decimal（string： &quot;hel1o&quot;）//
print（decima14）//nil
</code></pre>
<blockquote>
<p>Decimal 类型用于表示高精度的十进制数。由于直接将浮点数（如 Double）转换为 Decimal 可能会导致精度问题，因此需要使用字符串初始化 Decimal 以避免这种问题。</p></blockquote>
<pre><code class="language-swift">let a = Decimal（string： &quot;0.1&quot;）！ 
let b = Decimal（string： &quot;0.2&quot;）！
print（a + b） //0.3

//address the issue right?
</code></pre>
<h3 id="character--string-字符与字符串">Character &amp; String 字符与字符串</h3>
<p>在 Swift 中 <code>String</code> 类型是<em>值类型</em>。如果你创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。在前述任一情况下，都会对已有字符串值创建新副本，并对该新副本而非原始字符串进行传递或赋值操作。值类型在 <a href="https://gitbook.swiftgg.team/swift/swift-jiao-cheng/09_structures_and_classes#structures-and-enumerations-are-value-types">结构体和枚举是值类型</a> 中进行了详细描述。</p><blockquote>
<p><em>值类型</em>是这样一种类型，当它被赋值给一个变量、常量或者被传递给一个函数的时候，其值会被<em>拷贝</em>。</p><p>在之前的章节中，你已经大量使用了值类型。实际上，Swift 中所有的基本类型：整数（integer）、浮点数（floating-point number）、布尔值（boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，其底层也是使用结构体实现的。</p></blockquote>
<h4 id="扩展字符串分隔符">扩展字符串分隔符</h4>
<p>您可以将字符串文字放在扩展分隔符中，这样字符串中的特殊字符将会被直接包含而非转义后的效果。将字符串放在引号（<code>&quot;</code>）中并用数字符号（<code>#</code>）括起来。例如，打印字符串文字 <code>#&quot;Line 1 \nLine 2&quot;#</code> 会打印换行符转义序列（）而不是给文字换行。</p><pre><code class="language-swift">print(#&quot;Line 1 \nLine 2&quot;#)
//结果：Line 1 \nLine 2
</code></pre>
<p>如果要在使用扩展字符串分隔符的字符串中使用字符串插值，需要在反斜杠后面添加与开头和结尾数量相同扩展字符串分隔符。例如：</p><pre><code class="language-Swift">print(#&quot;6 times 7 is \#(6 * 7).&quot;#)
// 打印 &quot;6 times 7 is 42.&quot;
</code></pre>
<blockquote>
<p>注意</p><p>插值字符串中写在括号中的表达式不能包含非转义反斜杠（<code>\</code>），并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p></blockquote>
<h4 id="unicode">Unicode</h4>
<p><code>Character</code>由Unicode组成，<code>String</code> 由 <code>Character</code>组成</p><p>每一个 Swift 的 <code>Character</code>类型代表一个<em>可扩展的字形群 (Extended Grapheme Clusters)</em>。而一个可扩展的字形群构成了人类可读的单个字符，它由一个或多个（当组合时） Unicode 标量的序列组成。</p><p>具体来说，一个 String 可以包含一个或多个 Character，而每个 Character 可以包含一个或多个 Unicode 标量值。Swift 使用这种方式来确保字符串操作的正确性和一致性。</p><p>举个例子，String 的存储细节：</p><pre><code>你好棒👍 =&gt; 20320 22909 26834 128077 127998
</code></pre>
<blockquote>
<p>一个工具叫zalgo text文字生成器，可以随机组合Unicode生成一些乱码的文字</p></blockquote>
<p>在 Swift 中，当你操作字符串（比如连接或修改字符串）时，即使涉及到可扩展的字形群集，字符串的字符数量（Character 的数量）可能不会改变。这是因为 Character 代表的是一个完整的可扩展字形群集，而不仅仅是单个的 Unicode 标量值。</p><p>也就是说，当你使用<code>.count</code>属性计算一个 <code>String</code> 的长度时，计算的数字不是 Unicode 标量值（Unicode Scalar）的数量，而是字符串中可视字符（即 Character）的数量。</p><h4 id="四舍五入小数">四舍五入小数</h4>
<pre><code class="language-swift">let number = 123124.74023402394 

import Foundation 
let formatter = NumberFormatter()
formatter.maximumFractiohDigits = 2
print(formatter.string(for: number)!)
</code></pre>
<h3 id="enum-枚举声明">Enum 枚举声明</h3>
<p>你可以用Bool处理有两种可能性的东西，但是当一种东西不只有两种可能性，你可以用<code>enum</code>，比如<del>美国人的性别</del>但是，当然，任然是有限种选择。</p><p>Optional也是一种enum</p><h3 id="range">Range</h3>
<h3 id="三元条件运算符-ternary-conditional-operator">三元条件运算符 <em>ternary conditional operator</em></h3>
<p>三元<em>条件运算符</em>是一种特殊的运算符，由三部分组成，形式为<code>question ? answer1 : answer2</code>。</p><p>如果<code>question</code>为真，则评估<code>answer1</code>并返回其值；否则，评估<code>answer2</code>并返回其值。</p><p>三元条件运算符是以下代码的简写：</p><pre><code class="language-swift">if question {
    answer1
} else {
    answer2
}
</code></pre>
<h3 id="元组-tuples--类型别名-type-aliases">元组 <em>Tuples</em> &amp; 类型别名 <em>type aliases</em></h3>
<p><em>元组（tuples）</em> 把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p><blockquote>
<p>可以减去命名变量的痛苦，</p></blockquote>
<pre><code class="language-swift">let http404Error = (404, &quot;Not Found&quot;)
// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)
//http404Error.0 == 404
//http404Error.1 == &quot;Not Found&quot;
</code></pre>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 <code>(Int, Int, Int)</code> 或者 <code>(String, Bool)</code> 或者其他任何你想要的组合的元组。</p><h4 id="元组分解（decompose）">元组分解（decompose）:</h4>
<pre><code class="language-swift">let (statusCode, statusMessage) = http404Error
print(&quot;The status code is \(statusCode)&quot;)
// 输出“The status code is 404”
print(&quot;The status message is \(statusMessage)&quot;)
// 输出“The status message is Not Found”
</code></pre>
<p>你可以使用 <code>typealias</code> 关键字来定义类型别名。</p><p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p><pre><code class="language-swift">typealias AudioSample = UInt16
</code></pre>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p><pre><code class="language-swift">var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound 现在是 0
</code></pre>
<p>本例中，<code>AudioSample</code> 被定义为 <code>UInt16</code> 的一个别名。因为它是别名，<code>AudioSample.min</code> 实际上是 <code>UInt16.min</code>，所以会给 <code>maxAmplitudeFound</code> 赋一个初值 <code>0</code>。</p><blockquote>
<p>你可以把Tuples当做一个简单的类型使用</p></blockquote>
<pre><code class="language-swift">typealias Human = （String, Double, String）
let man: Human = (&quot;A&quot;,10.2,&quot;B&quot;)// 建立了一个“Human类型&quot;，但其实本质上是一个元祖
</code></pre>
<h3 id="set--hashable">Set &amp; Hashable</h3>
<p>在 Swift 中，Hashable 是一种协议，类型可以遵循该协议以便在字典中用作键或存储在集合中。当一个类型遵循 Hashable 时，这意味着该类型的实例可以被哈希为 Int 类型的值，该值用于唯一标识该实例。</p><p><strong>Why Hashable?</strong></p><ul>
<li><strong>Dictionary Keys</strong>: When using a type as a key in a dictionary, the dictionary needs to quickly look up, add, and remove values. Hashing allows for efficient access.</li>
<li><strong>Set Elements</strong>: Sets rely on hashing to ensure that elements are unique and to quickly check for membership.</li>
<li><strong>Performance</strong>: Hashing provides constant-time complexity for operations like lookups, insertions, and deletions in hash-based collections.</li>
</ul>
<p>Hashing is a fundamental concept in computer science that provides efficient data retrieval, especially in hash-based collections like dictionaries and sets.</p><ul>
<li><strong>Hash Function</strong>: Transforms keys into hash values.</li>
<li><strong>Hash Table</strong>: Uses hash values to index and store key-value pairs.</li>
<li><strong>Collision Handling</strong>: Manages cases where multiple keys produce the same hash value.</li>
<li><strong>Efficiency</strong>: Direct indexing allows for constant-time complexity (O(1)) for insertions, deletions, and lookups on average.</li>
</ul>
<h4 id="how-hashing-works">How Hashing Works</h4>
<ol>
<li><p><strong>Hash Function</strong>: When an object (like a key in a dictionary) needs to be stored or retrieved, a hash function is applied to the object. This function computes a hash value (an integer) from the object’s data.</p></li>
<li><p><strong>Hash Table</strong>: This hash value is then used as an index to place the object in a hash table (an array). The hash table is a data structure that maps keys to values using the computed hash values.</p></li>
</ol>
<h4 id="ensuring-quick-lookups">Ensuring Quick Lookups</h4>
<ul>
<li><p><strong>Direct Access</strong>: Since the hash value directly maps to an index in the hash table, accessing the data can be done in constant time, O(1). This means that the time it takes to retrieve the value does not depend on the number of elements in the table.</p></li>
<li><p><strong>Uniform Distribution</strong>: A good hash function distributes hash values uniformly across the hash table, minimizing the number of collisions (when two different objects produce the same hash value).</p></li>
</ul>
<h4 id="handling-collisions-处理哈希碰撞">Handling Collisions 处理哈希碰撞</h4>
<p>Collisions are inevitable in hashing because different objects can produce the same hash value. However, efficient techniques exist to handle collisions:</p><ol>
<li><p><strong>Chaining</strong>: Each index in the hash table points to a linked list (or another collection) of entries that have the same hash value. When a collision occurs, the new entry is added to the list at that index. Lookup operations involve scanning the list, which is generally short if the hash function distributes values well.</p><pre><code class="language-plaintext">Hash Table (using chaining):
Index  | Entries
0      | [ ]
1      | [ ]
2      | [ ]
3      | [ &quot;Key1&quot; -&gt; &quot;Value1&quot;, &quot;Key2&quot; -&gt; &quot;Value2&quot; ]
4      | [ ]
</code></pre>
</li>
<li><p><strong>Open Addressing</strong>: When a collision occurs, the hash table looks for another open slot using a probing sequence (linear probing, quadratic probing, or double hashing). The lookup operation follows the same probing sequence to find the correct slot.</p><pre><code class="language-plaintext">Hash Table (using linear probing):
Index  | Entry
0      | [ ]
1      | [ ]
2      | [ &quot;Key2&quot; -&gt; &quot;Value2&quot; ]
3      | [ &quot;Key1&quot; -&gt; &quot;Value1&quot; ]
4      | [ ]
</code></pre>
</li>
</ol>
<h4 id="constant-time-complexity">Constant-Time Complexity</h4>
<p>Hashing ensures that the average time complexity for insertions, deletions, and lookups is O(1) under the following conditions:</p><ul>
<li><strong>Good Hash Function</strong>: A well-designed hash function that minimizes collisions and distributes keys uniformly.</li>
<li><strong>Load Factor Management</strong>: The load factor (number of entries divided by the number of slots in the hash table) is kept low by resizing the table when necessary (rehashing). This ensures that the number of entries in each slot remains small.</li>
</ul>
<p>一个类型为了存储在集合中，该类型必须是<em>可哈希化</em>的——也就是说，该类型必须提供一个方法来计算它的<em>哈希值</em>。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如 <code>a == b</code>,因此必须 <code>a.hashValue == b.hashValue</code>。</p><p>Swift 的所有基本类型（比如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希化的，可以作为集合值的类型或者字典键的类型。没有关联值的枚举成员值（在 <a href="https://gitbook.swiftgg.team/swift/swift-jiao-cheng/08_enumerations">枚举</a> 有讲述）默认也是可哈希化的。</p><p><code>Set</code>是一种遵照Hashable的类型，也就是数学中的集合，可以做集合运算，以及在集合中不能有重复的元素，所以很好理解，可以它声明为Hashable。</p><p>Swift 中的集合类型被写为 <code>Set&lt;Element&gt;</code>，这里的 <code>Element</code> 表示集合中允许存储的类型。和数组不同的是，集合没有等价的简化形式。</p><pre><code class="language-swift">var letters = Set&lt;Character&gt;()
print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;)
// 打印“letters is of type Set&lt;Character&gt; with 0 items.”
</code></pre>
<blockquote>
<p>注意</p><p>通过构造器，这里 <code>letters</code> 变量的类型被推断为 <code>Set&lt;Character&gt;</code>。</p></blockquote>
<p>一个集合类型不能从数组字面量中被直接推断出来，因此 <code>Set</code> 类型必须显式声明。然而，由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个集合并且与该数组字面量中的所有元素类型相同，那么无须写出集合的具体类型。<code>favoriteGenres</code> 的构造形式可以采用简化的方式代替：</p><pre><code class="language-swift">// Two ways to declare
var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
// favoriteGenres 被构造成含有三个初始值的集合

var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>
<p>由于数组字面量中的所有元素类型相同，Swift 可以推断出 <code>Set&lt;String&gt;</code> 作为 <code>favoriteGenres</code> 变量的正确类型。</p><h4 id="集合的一些数学操作">集合的一些数学操作</h4>
<ul>
<li>使用 <code>intersection(_:)</code> 方法根据两个集合的交集创建一个新的集合。</li>
<li>使用 <code>symmetricDifference(_:)</code> 方法根据两个集合不相交的值创建一个新的集合。</li>
<li>使用 <code>union(_:)</code> 方法根据两个集合的所有值创建一个新的集合。</li>
<li>使用 <code>subtracting(_:)</code> 方法根据不在另一个集合中的值创建一个新的集合。</li>
</ul>
<pre><code class="language-Swift">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre>
<ul>
<li>使用“是否相等”运算符（<code>==</code>）来判断两个集合包含的值是否全部相同。</li>
<li>使用 <code>isSubset(of:)</code> 方法来判断一个集合中的所有值是否也被包含在另外一个集合中。</li>
<li>使用 <code>isSuperset(of:)</code> 方法来判断一个集合是否包含另一个集合中所有的值。</li>
<li>使用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code> 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li>
<li>使用 <code>isDisjoint(with:)</code> 方法来判断两个集合是否不含有相同的值（是否没有交集）。</li>
</ul>
<pre><code class="language-swift">let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]
let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]
let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre>
<h2 id=""></h2>
<h3 id="可选类型（optionals）">可选类型*（optionals）*</h3>
<p>可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。</p><p><strong>An Example:</strong></p><p>Swift 的 <code>Int</code> 类型有一种<em>构造器</em>，作用是将一个 <code>String</code> 值转换成一个 <code>Int</code> 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 <code>&quot;123&quot;</code> 可以被转换成数字 <code>123</code> ，但是字符串 <code>&quot;hello, world&quot;</code> 不行。</p><blockquote>
<p>构造器是一种特殊的函数，用于创建类、结构体或枚举的实例。它们不返回值，而是负责初始化实例的所有属性，并确保实例在第一次使用前处于有效状态。</p><pre><code class="language-swift">struct Person {
 var name: String
 var age: Int

 init(name: String, age: Int) { //就是构造函数
     self.name = name
     self.age = age
 }
}

let person = Person(name: &quot;John&quot;, age: 25)
</code></pre>
</blockquote>
<p>下面的例子使用这种构造器来尝试将一个 <code>String</code> 转换成 <code>Int</code>：</p><pre><code class="language-Swift">let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;
</code></pre>
<p>因为该构造器可能会失败，所以它返回一个 <em>可选类型</em> （optional）<code>Int</code>，而不是一个 <code>Int</code>。一个可选的 <code>Int</code> 被写作 <code>Int?</code> 而不是 <code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含 <code>Int</code> 值也可能 <em>不包含值</em> 。（不能包含其他任何值比如 <code>Bool</code> 值或者 <code>String</code> 值。只能是 <code>Int</code> 或者什么都没有。）</p><h4 id="nil">nil</h4>
<p>你可以给可选变量赋值为 <code>nil</code> 来表示它没有值：</p><pre><code class="language-Swift">var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre>
<blockquote>
<p>注意</p><p><code>nil</code> 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p></blockquote>
<p>如果你声明一个可选变量但是没有赋值，它们会自动被设置为 <code>nil</code>：</p><pre><code class="language-swift">var surveyAnswer: String?
// surveyAnswer 被自动设置为 nil
</code></pre>
<blockquote>
<p>注意</p><p>Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。</p></blockquote>
<h4 id="if-语句以及强制解析">if 语句以及强制解析</h4>
<p>你可以使用 <code>if</code> 语句和 <code>nil</code> 比较来判断一个可选值是否包含值。你可以使用“相等”(<code>==</code>)或“不等”(<code>!=</code>)来执行比较。</p><p>如果可选类型有值，它将不等于 <code>nil</code>：</p><pre><code class="language-swift">if convertedNumber != nil {
    print(&quot;convertedNumber contains some integer value.&quot;)
}
// 输出“convertedNumber contains some integer value.”
</code></pre>
<p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的 <em>强制解析（forced unwrapping）</em> ：</p><pre><code class="language-swift">if convertedNumber != nil {
    print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)
}
// 输出“convertedNumber has an integer value of 123.”
</code></pre>
<p>更多关于 <code>if</code> 语句的内容，请参考 <a href="https://gitbook.swiftgg.team/swift/swift-jiao-cheng/05_control_flow">控制流</a>。</p><blockquote>
<p>注意</p><p>使用 <code>!</code> 来获取一个不存在的可选值会导致运行时错误。使用 <code>!</code> 来强制解析值之前，一定要确定可选包含一个非 <code>nil</code> 的值。</p></blockquote>
<h2 id="函数">函数</h2>
<p>一些关于函数的概念：</p><ol>
<li><strong>形参（Formal Parameters 形式参数）</strong>：在函数定义中声明的参数，它们是函数内部使用的变量，用于接收传递给函数的值。</li>
<li><strong>实参（Actual Parameters 实际参数）</strong>：在函数调用时传递给函数的值，它们是实际的数据，用于初始化形参。</li>
<li><strong>返回类型</strong>：函数可以返回一个值，这个值的类型就是返回类型。如果函数不返回任何值，则返回类型为<code>void</code>。</li>
<li><strong>方法（Method）</strong>：在面向对象编程中，方法是与对象相关联的函数。它通常可以访问和操作对象的属性。</li>
<li><strong>属性（Property）</strong>：对象的属性是与对象状态相关的变量。在面向对象编程中，属性可以是变量或函数，用于表示对象的状态。</li>
</ol>
<blockquote>
<p>属性如何作为函数？在面向对象编程（OOP）中，属性可以被看作是对象的特征或状态，它们可以是简单的变量，也可以是通过计算得到的值，这就涉及到计算属性的概念。</p></blockquote>
<h3 id="函数参数名称与参数标签">函数参数名称与参数标签</h3>
<p>在Swift中，函数参数可以有两个名字：一个是参数标签（argument label），另一个是参数名称（parameter name）。参数标签在函数调用时使用，而参数名称在函数体内使用。</p><blockquote>
<p>有点绕，简单点说就是第一个<strong>参数标签</strong>用于调用的时候，第二个参数名称用于函数体里面用</p></blockquote>
<pre><code class="language-swift">func greet(person name: String) {
   //greet(参数标签 参数名称: String)
    print(&quot;Hello, \(name)!&quot;)
}

greet(person: &quot;Alice&quot;)
// 调用时使用参数标签 person
</code></pre>
<p>可以省略参数标签：</p><pre><code class="language-swift">func greet(_ name: String) {
    print(&quot;Hello, \(name)!&quot;)
}

greet(&quot;Alice&quot;)
// 这样就类似C++里面的调用方式
</code></pre>
<p><strong>参数标签和参数名称</strong></p><ul>
<li><strong>两个名称</strong>（参数标签和参数名称）：第一个名称是参数标签，用于函数调用时，第二个名称是参数名称，用于函数体内。</li>
<li><strong>一个名称</strong>（参数标签和参数名称相同）：如果只有一个名称，它既是参数标签，又是参数名称。</li>
</ul>
<pre><code class="language-swift">print(_: separator: terminator:)
//很明显这个separator就是参数标签==参数名称
</code></pre>
<h3 id="可变参数">可变参数</h3>
<p>一个*可变参数（variadic parameter）*可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（<code>...</code>）的方式来定义可变参数。</p><p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p><p>下面的这个函数用来计算一组任意长度数字的 <em>算术平均数（arithmetic mean)</em>：</p><pre><code class="language-Swift">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// 返回 3.0, 是这 5 个数的平均数。
arithmeticMean(3, 8.25, 18.75)
// 返回 10.0, 是这 3 个数的平均数。
</code></pre>
<p>一个函数能拥有多个可变参数。可变参数后的第一个形参前必须加上实参标签。实参标签用于区分实参是传递给可变参数，还是后面的形参。</p><p><code>print</code>中：</p><pre><code class="language-swift">func print(_ items: Any..., separator: String = &quot; &quot;, terminator: String = &quot;\n&quot;)
</code></pre>
<p>使用的<code>Any...</code>就表示可以用很多不同的类型，而且可以同时传入很多，(比如Int String Character etc.)</p><p><code>String = &quot; &quot;</code>这个是预设数值</p><h3 id="多重返回值函数">多重返回值函数</h3>
<p>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p><p>下例中定义了一个名为 <code>minMax(array:)</code> 的函数，作用是在一个 <code>Int</code> 类型的数组中找出最小值与最大值。</p><pre><code class="language-Swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int) { //多了一个(min: Int, max: Int)用于查询函数的返回值
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

//(currentMin, currentMax) -&gt; (min: Int, max: Int) 变量改为了上面所定义的min与max
</code></pre>
<p><code>minMax(array:)</code> 函数返回一个包含两个 <code>Int</code> 值的元组，这些值被标记为 <code>min</code> 和 <code>max</code> ，<strong>以便查询函数的返回值时可以通过名字访问它们。</strong></p><p>在 <code>minMax(array:)</code> 的函数体中，在开始的时候设置两个工作变量 <code>currentMin</code> 和 <code>currentMax</code> 的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比 <code>currentMin</code> 和 <code>currentMax</code> 更小或更大。最后数组中的最小值与最大值作为一个包含两个 <code>Int</code> 值的元组返回。</p><p><strong>因为元组的成员值已被命名</strong>，因此可以通过 <code>.</code> 语法来检索找到的最小值与最大值：</p><pre><code class="language-Swift">let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
// 打印“min is -6 and max is 109”
</code></pre>
<p>需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</p><h3 id="面向对象-oop-的哲学">面向对象 OOP 的哲学</h3>
<p>面向对象编程（OOP）是一种编程范式，强调将数据和操作数据的代码封装在一起，称之为“对象”。OOP的哲学在于模拟现实世界，通过对象和类来表示和组织程序。</p><h4 id="核心概念">核心概念</h4>
<ol>
<li><strong>对象（Object）</strong>：现实世界中的实体在程序中的抽象。对象具有属性（数据）和方法（行为）。</li>
<li><strong>类（Class）</strong>：对象的蓝图或模板。类定义了对象的属性和方法。</li>
<li><strong>封装（Encapsulation）</strong>：将数据和操作数据的方法封装在对象内部，隐藏实现细节。</li>
<li><strong>继承（Inheritance）</strong>：一个类可以继承另一个类的属性和方法，促进代码重用。</li>
<li><strong>多态（Polymorphism）</strong>：对象可以用多种形式存在，允许不同对象以相同接口调用。</li>
</ol>
<h4 id="为什么叫面向对象">为什么叫“面向对象”</h4>
<p>“面向对象”这个词反映了这种编程方法的核心：以对象为中心。程序中的所有东西都是对象，或者与对象相关。对象代表了程序中的实体，类定义了这些实体的结构和行为。</p><h5 id="面向对象-vs-面向过程">面向对象 vs 面向过程</h5>
<ul>
<li><strong>面向过程编程（Procedural Programming）</strong>：将程序视为一系列步骤或过程（函数）的集合。程序的焦点在于函数和过程的调用顺序。</li>
<li><strong>面向对象编程（Object-Oriented Programming）</strong>：将程序视为对象的集合。程序的焦点在于对象及其交互。</li>
</ul>
<h5 id="面向对象的本质和内涵">面向对象的本质和内涵</h5>
<ul>
<li><strong>模拟现实</strong>：通过对象和类模拟现实世界中的实体和关系。</li>
<li><strong>组织代码</strong>：通过类和对象组织代码，使其更具可读性和可维护性。</li>
<li><strong>封装和抽象</strong>：隐藏实现细节，只暴露必要的接口。</li>
<li><strong>复用性和可扩展性</strong>：通过继承和多态实现代码复用和扩展。</li>
</ul>
<h5 id="对象的真实含义">对象的真实含义</h5>
<p>在OOP中，对象是程序中的基本单元，包含了属性和方法：</p><ul>
<li><strong>属性（Attributes）</strong>：对象的状态或数据。</li>
<li><strong>方法（Methods）</strong>：对象的行为或功能。</li>
</ul>
<p>例如，一个“Person”对象可能有“name”和“age”属性，以及“greet”方法。</p><h5 id="计算属性">计算属性</h5>
<p>**计算属性是类或结构体中的属性，但它们的值不是直接存储的，而是通过计算得来的。**计算属性本质上是getter和setter函数：</p><ul>
<li><strong>Getter</strong>：返回计算属性的值。</li>
<li><strong>Setter</strong>：设置计算属性的值。</li>
</ul>
<h4 id="为什么属性可以作为函数">为什么属性可以作为函数</h4>
<p>计算属性之所以可以作为函数，是因为它们通过getter和setter函数计算和设置值。这样，属性的值可以根据其他属性动态计算，而不需要显式存储。</p><h4 id="示例：计算属性">示例：计算属性</h4>
<pre><code class="language-swift">class Circle {
    var radius: Double

    var circumference: Double {
        get {
            return 2 * .pi * radius
        }
        set {
            radius = newValue / (2 * .pi)
        }
    }

    init(radius: Double) {
        self.radius = radius
    }
}

let circle = Circle(radius: 5)
print(circle.circumference) // 输出 31.4159

circle.circumference = 31.4159
print(circle.radius) // 输出 5
</code></pre>
<p>在这个示例中，<code>circumference</code> 是一个计算属性，通过getter和setter函数计算和设置圆的周长和半径。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>AI目前的影响</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/aimu-qian-de-ying-xiang.html"/>
        <id>https://scooorpion.github.io/aimu-qian-de-ying-xiang.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/18/google-deepmind-JwcgMh7qXw-unsplash.jpg" medium="image" />
            <category term="Thought"/>

        <updated>2024-06-28T00:57:00+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/18/google-deepmind-JwcgMh7qXw-unsplash.jpg" alt="" />
                    <p>其实信息时代$AI$最大的好处就是可以免除信息茧房，减少算法的影响，不会被广告，不实信息，等诸多因素干扰。</p>
<p>目前的所有搜索习惯，以及聊天，无论是学业上的，英语口语，甚至是生病吃什么药，都完全离不开大模型的帮助。以至于我不需要再使用搜索引擎，直接与AI语音对话，效率是最高的。</p>

                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/18/google-deepmind-JwcgMh7qXw-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>其实信息时代$AI$最大的好处就是可以免除信息茧房，减少算法的影响，不会被广告，不实信息，等诸多因素干扰。</p>
<p>目前的所有搜索习惯，以及聊天，无论是学业上的，英语口语，甚至是生病吃什么药，都完全离不开大模型的帮助。以至于我不需要再使用搜索引擎，直接与AI语音对话，效率是最高的。</p>

<p>$ChatGPT$ 甚至可以通过我画的图例理解我的问题，豆包可以直接通过我的highlight来搜索，这两个实实在在的大幅提升了我的效率，而且不会收不良因素干扰。</p>
<p>以前$AI$是辅助品，现在搜索引擎反而成为替代品了。</p>
<p>是的，我一直认为目前以$LLM$的能力，最大的作用就是替代搜索引擎，因为其有强大的信息整合结合能力。</p>
<p>至于绘图，什么其它的内容，只是锦上添花罢了，实操起来其实并非效率有人工高。</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>The microscopic expression of pressure</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/pressure.html"/>
        <id>https://scooorpion.github.io/pressure.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/17/jj-ying-WmnsGyaFnCQ-unsplash.jpg" medium="image" />
            <category term="Physics"/>

        <updated>2024-06-23T10:31:30+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/17/jj-ying-WmnsGyaFnCQ-unsplash.jpg" alt="" />
                    1. 引言 我们将推导气体压强的微观表达式，通过分子动理论来解释单个分子如何产生宏观压强，并引出玻尔兹曼常数&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/17/jj-ying-WmnsGyaFnCQ-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <h4 id="1-引言">1. 引言</h4>
<p>我们将推导气体压强的微观表达式，通过分子动理论来解释单个分子如何产生宏观压强，并引出玻尔兹曼常数 $ k_B $的意义和作用。</p><h4 id="2-压强的微观定义">2. 压强的微观定义</h4>
<p>压强$ P $是气体分子对单位面积容器壁施加的平均力：
$$ P = \frac{F}{A} $$
其中 $F$ 是分子施加在容器壁上的总力， $A$ 是容器壁的面积。</p><h4 id="3-单个分子对容器壁的冲量">3. 单个分子对容器壁的冲量</h4>
<p>假设气体分子的质量为 $ m $，速度为 $ v $。一个分子沿着 $ x $ 方向撞击容器壁，并发生弹性碰撞，速度变为 $ -v_x $。碰撞前后的速度变化为：
$$ \Delta v_x = v_x - (-v_x) = 2v_x $$
力的变化等于动量的变化率，根据冲量定理：
$$ \Delta p_x = 2mv_x $$</p><h4 id="4-单个分子对容器壁的力">4. 单个分子对容器壁的力</h4>
<p>考虑在时间 $ t $ 内，一个分子撞击容器壁的次数。若容器的长度为 $ L $，那么一个分子从一壁到另一壁并返回所需时间为：
$$ \Delta t = \frac{2L}{v_x} $$
在时间 $ t $ 内，撞击次数为：
$$ n = \frac{t}{\Delta t} = \frac{t v_x}{2L} $$
每次碰撞产生的力为：
$$ F_x = \frac{\Delta p_x}{\Delta t} = \frac{2mv_x}{\frac{2L}{v_x}} = \frac{mv_x^2}{L} $$</p><h4 id="5-总力和压强">5. 总力和压强</h4>
<p>对于 $ N $ 个分子，由于分子运动是随机的，均匀分布在三个方向（$ x $、$ y $、$ z $）。在立方体容器中，三维运动的平均速度平方 $ \langle v^2 \rangle $ 在每个方向的分量为：
$$ \langle v_x^2 \rangle = \langle v_y^2 \rangle = \langle v_z^2 \rangle = \frac{\langle v^2 \rangle}{3} $$
总力为：
$$ F = N \cdot \frac{mv_x^2}{L} = N \cdot \frac{m \cdot \frac{\langle v^2 \rangle}{3}}{L} = \frac{N m \langle v^2 \rangle}{3L} $$
压强 $ P $ 为：
$$ P = \frac{F}{A} = \frac{F}{L^2} = \frac{N m \langle v^2 \rangle}{3L^3} $$</p><h4 id="6-体积与温度的关系">6. 体积与温度的关系</h4>
<p>由于 $ L^3 = V $（容器的体积），压强变为：
$$ P = \frac{N m \langle v^2 \rangle}{3V} $$
进一步，用理想气体状态方程 $ PV = Nk_B T $（其中 $ k_B $ 是玻尔兹曼常数， $ T $ 是温度），我们可以联系温度和分子的平均动能：
$$ \frac{N m \langle v^2 \rangle}{3V} = \frac{Nk_B T}{V} $$
$$ \frac{m \langle v^2 \rangle}{3} = k_B T $$
由此，我们得出分子的平均动能与温度的关系：
$$ \frac{1}{2} m \langle v^2 \rangle = \frac{3}{2} k_B T $$
这是分子动理论的基本结果，表示了气体分子的平均动能和温度之间的关系。</p><h3 id="玻尔兹曼常数--k_b--的解释">玻尔兹曼常数 $ k_B $ 的解释</h3>
<h4 id="1-玻尔兹曼常数的定义">1. 玻尔兹曼常数的定义</h4>
<p>玻尔兹曼常数 $ k_B $ 是一个基本物理常数，连接了微观的分子运动与宏观的热力学性质。其值约为：
$$ k_B \approx 1.380649 \times 10^{-23} , \text{J/K} $$</p><h4 id="2-玻尔兹曼常数的作用">2. 玻尔兹曼常数的作用</h4>
<ul>
<li><strong>微观与宏观的桥梁</strong>：玻尔兹曼常数将单个分子或原子的能量尺度与宏观的温度尺度联系起来。</li>
<li><strong>理想气体状态方程</strong>：在理想气体状态方程中，玻尔兹曼常数用于描述气体分子平均动能和温度的关系：
$$ PV = Nk_B T $$</li>
<li><strong>气体分子的平均动能</strong>：单个气体分子的平均动能与温度的关系为：
$$ \langle E_k \rangle = \frac{3}{2} k_B T $$</li>
<li><strong>熵的统计定义</strong>：玻尔兹曼常数也出现在熵的统计定义中：
$$ S = k_B \ln \Omega $$</li>
</ul>
<h4 id="3-理想气体常数--r--与玻尔兹曼常数的关系">3. 理想气体常数 $ R $ 与玻尔兹曼常数的关系</h4>
<p>理想气体常数 $ R $ 与玻尔兹曼常数 $ k_B $ 通过阿伏伽德罗常数 $ N_A $ 连接：
$$ R = N_A k_B $$
其中 $ N_A $ 是阿伏伽德罗常数，约为：
$$ N_A \approx 6.022 \times 10^{23} , \text{mol}^{-1} $$</p><p>通过分子动理论，我们推导了气体压强的微观表达式，并解释了玻尔兹曼常数在这一过程中扮演的重要角色。玻尔兹曼常数 $ k_B $ 是将微观粒子的运动行为与宏观热力学性质（如温度和压强）联系起来的桥梁，是统计力学和热力学中不可或缺的常数。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>历史</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/li-shi.html"/>
        <id>https://scooorpion.github.io/li-shi.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/15/camille-brodard-AVi4lkHl5L4-unsplash.jpg" medium="image" />
            <category term="Thought"/>

        <updated>2024-06-16T23:50:50+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/15/camille-brodard-AVi4lkHl5L4-unsplash.jpg" alt="" />
                    历史是隐形的 中国上下五千年的历史文化，积累的哲学，科学，人文。已经可以对待任何事情，任何事物。而世界上一切冲突的本质其实都是人的私利，生死，社会达尔文主义说明了这一点。我们的祖先早已看透了人性，看透了一切事物的本源。而西方只能在基本事实和表面上看待问题 这就是东西方的最大差别，也是东方相较于西方的最大优势。
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/15/camille-brodard-AVi4lkHl5L4-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                
  <p>
    <br>历史是隐形的<br><br>中国上下五千年的历史文化，积累的哲学，科学，人文。已经可以对待任何事情，任何事物。而世界上一切冲突的本质其实都是人的私利，生死，社会达尔文主义说明了这一点。我们的祖先早已看透了人性，看透了一切事物的本源。而西方只能在基本事实和表面上看待问题
  </p>

  <p>
    这就是东西方的最大差别，也是东方相较于西方的最大优势。
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Dora-ERC404 概述</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/dora-erc404-gai-shu.html"/>
        <id>https://scooorpion.github.io/dora-erc404-gai-shu.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/9/xavier-von-erlach-d-3jJUO74Go-unsplash.jpg" medium="image" />
            <category term="Blockchain"/>

        <updated>2024-06-02T15:58:33+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/9/xavier-von-erlach-d-3jJUO74Go-unsplash.jpg" alt="" />
                    Dora-ERC404是一种基于以太坊区块链的代币标准，它在功能和特性上融合了以往的代币标准，如ERC-20和ERC- 721。在区块链世界里，不同类型的代币标准经常因其设计目的不同而有所区别。ERC-20是最为广泛认可的代币标准 之一，它被用来创建和发行可替代的数字货币和其他资产，这些代币是"同质化的"，意味着每个代币都是等价的并可&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/9/xavier-von-erlach-d-3jJUO74Go-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <div class="page" title="Page 1">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column"> </div>
</div>
<div class="layoutArea">
<div class="column">
<p>Dora-ERC404是一种基于以太坊区块链的代币标准，它在功能和特性上融合了以往的代币标准，如ERC-20和ERC- 721。在区块链世界里，不同类型的代币标准经常因其设计目的不同而有所区别。ERC-20是最为广泛认可的代币标准 之一，它被用来创建和发行可替代的数字货币和其他资产，这些代币是"同质化的"，意味着每个代币都是等价的并可 以相互替换。然而，ERC-721代币标准引入了"非同质化代币"(NFTs)的概念，每个ERC-721代币都是独一无二的， 不可分割，代表了区块链上的独特资产。</p>
<p>Dora-ERC404应运而生，试图弥合ERC-20和ERC-721之间的差异，创造一种既可以表现为同质化又可以表现为非同质 化的代币。简而言之，Dora-ERC404的代币既可以像ERC-20代币那样，作为货币或权利的等价物流通，也可以像ERC- 721代币那样，代表唯一的、可收集的数字资产。这种"半同质化"的代币，在特定的场景下根据需要转换其属性，提供 了一种灵活性和多样性，这在以往的代币标准中是不常见的。</p>
<p>不同于纯粹的ERC-20标准，Dora-ERC404允许代币在某些条件下是可替代的，在其他条件下保持唯一性。这种灵活的 设计使得它可以适应多种不同的用例，比如电子票务、游戏中的道具，或者任何需要跨越同质化和非同质化资产边界 的应用。此外，Dora-ERC404在智能合约的实施上也具有高度的灵活性和可定制性，使得开发者能够创造出符合自己 业务逻辑需求的代币系统。</p>
<p>Dora-ERC404与ERC-20和ERC-721相比，其独特之处不仅在于它的半同质性。在一些实现上，Dora-ERC404采用了更 加先进的编程模式和安全措施，目的是为了提高交易的效率以及减少网络的拥堵。Dora-ERC404代币的智能合约设计 有助于简化用户和开发者在管理和交易代币时的流程，同时还提供了足够的保护措施来确保资产安全。</p>
<p>在以太坊区块链上，Dora-ERC404代币由符合标准的智能合约管理，这些合约定义了代币的创建(铸造)，转移，销 毁(燃烧)等规则。通过这些操作，Dora-ERC404为用户提供了与传统ERC-20和ERC-721不同的体验，并在某些情况 下能够更好地满足市场需求。</p>
<p>Dora-ERC404的技术架构以其灵活性和多功能性著称，在以太坊网络中为代币的使用提供了新的可能性。在其核心， Dora-ERC404利用了智能合约的能力来实现其独特的操作和管理代币的方式。</p>
<p>智能合约是一种在区块链上运行的自动化脚本，它们在特定条件满足时自行执行预先编程的动作。Dora-ERC404的智 能合约编写遵循着严格的编程规范，确保合约代码的安全性、高效性以及透明性。此外，智能合约的不可变性保证了 一旦部署，其规则就不可篡改，从而确保了网络参与者之间的信任。</p>
<p>为了实现代币的半同质性，Dora-ERC404智能合约包含了一系列复杂的逻辑判断和条件语句。它们能够根据代币的当 前使用场景和持有者的需求，动态地调整代币的属性。比如，在特定的应用场景下，一个Dora-ERC404代币可以表现 为可替代的同质化代币，而在另一场景下，则表现为具有独特属性和不可替代性的非同质化代币(NFT)。</p>
<p>在执行交易时，Dora-ERC404智能合约会进行一系列的验证过程，以确定交易请求是否合法和有效。一旦验证通过， 合约会自动执行相应的代币转移或状态变更。这些操作包括代币的铸造、转移和销毁等。通过这种方式，Dora- ERC404确保了交易的可靠性和网络的安全性。</p>
<p>智能合约中还设有一系列的安全机制，如时间锁、权限控制和事件日志记录等功能，以应对潜在的安全威胁和提供交 易的全程透明度。Dora-ERC404标准强调安全性设计，通过代码审计和测试来降低智能合约的潜在漏洞和风险。</p>
<p>在以太坊网络中，Dora-ERC404代币的交易依赖于以太坊的底层技术，例如以太坊虚拟机(EVM)。EVM是一个全球 性的、强大的分布式计算环境，它使得智能合约得以在全球范围内被无障碍地执行。每当用户发起一个Dora-ERC404 代币的交易请求时，EVM会处理这些请求，执行智能合约中的代码，并将交易记录在区块链上。这一过程保证了交易 的不可篡改性和持久性。</p>
</div>
</div>
</div>
</div>
</div>
<div class="page" title="Page 2">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>Dora-ERC404智能合约还具备处理交易费用的能力。为了执行交易或调用智能合约中的某个函数，用户需支付一定量 的“gas”作为计算资源消耗的费用。这种费用结构保障了网络资源的合理分配，并防止了恶意用户滥用网络资源。</p>
<p>总之，Dora-ERC404通过其精心设计的智能合约架构，在以太坊网络中实现了代币操作的多样性和灵活性。它提供了 一种高效、安全且自动化的方式来处理复杂的代币交易，丰富了数字资产的表现形式，并有望在诸多应用场景中发挥 重要作用。</p>
<p>Dora-ERC404代币标准在数字资产领域中的独特之处在于其创新的"半同质性"特性。与传统的同质化代币(如ERC- 20)或完全非同质化的代币(如ERC-721)不同，Dora-ERC404设计了一种新型代币，可以根据需要和场景灵活地切 换其属性，兼具同质化和非同质化代币的特性。这种独特的设计为数字资产领域带来了以下几方面的创新和竞争力提 升。</p>
<p>首先，Dora-ERC404代币的可适应性极强。传统的同质化代币往往限于特定用途，如代表一种货币或积分，而非同质 化代币则通常与一件独一无二的资产挂钩，比如艺术品或收藏品。Dora-ERC404打破了这一局限，可以在必要时作为 一种货币使用，同时在其他情况下又可以代表具有独特属性的资产，使得它在各种商业模式和市场场景下都能发挥作 用。</p>
<p>其次，这种灵活性意味着Dora-ERC404可以实现资源的优化配置。在游戏或数字收藏品等行业，一个代币可能初期作 为一种同质化资源被广泛分发，但随着时间或特定成就的解锁，这个代币可以演变成一个具有特殊意义和价值的非同 质化代币。例如，游戏中的通用道具通过特定事件变成了独特的纪念品。Dora-ERC404使得这种转变得以无缝执行， 为用户创造了更深层次的参与感和价值。</p>
<p>第三，Dora-ERC404的设计还促进了新的经济模型和创收渠道的探索。由于这种代币可以在不同属性间转换，它开启 了如动态定价、时间敏感奖励、特定事件触发奖励等多种经济激励模型的可能性。这对于创造粘性用户体验、鼓励用 户深度参与和开辟新的收益来源尤为重要。</p>
<p>此外，Dora-ERC404在保障用户资产安全方面也做出了创新。由于它结合了同质化和非同质化代币的特点，智能合约 中固有的安全机制能够有效抵御多种攻击手段，比如双重花费或合约漏洞。这一点对于增强用户的信任和推广代币使 用至关重要。</p>
<p>Dora-ERC404还有助于减少区块链网络的拥堵。在以太坊等区块链网络上，交易费用(gas费)往往与网络的拥挤程度 挂钩。通过将多个功能融合到一个代币标凈中，Dora-ERC404减少了对多个智能合约的需求，从而降低了每个交易所 需要的gas费，增强了网络效率，并对用户是一种节省成本的优势。</p>
<p>最后，随着区块链和加密资产被越来越多的主流用户所接受，Dora-ERC404的"半同质性"特性可能成为连接加密世界 和传统金融世界的桥梁。通过将传统资产如房产、艺术品等代表为在特定情况下可以被分割和共有的代币，Dora- ERC404为资产的分割所有权和流动性提供了新的解决方案。</p>
<p>综上所述，Dora-ERC404通过其创新的代币标准，为数字资产领域提供了更多样化的使用场景和经济互动模式，增加 了代币的可用性和流动性，同时提高了网络的运行效率和用户资产的安全性。这些特点使得Dora-ERC404具备了在数 字资产领域中的竞争优势，并为未来的市场发展提供了广阔的可能性。</p>
<p>Dora-ERC404的历史发展可追溯至数字资产和区块链行业对代币多样性和可塑性需求的增长。在早期的区块链发展阶 段，市场上主导的是同质化代币标准，如ERC-20，它极大地促进了加密货币的流通与交换。然而，随着区块链技术的 不断成熟及应用场景的扩展，市场开始出现对非同质化代币的需求，特别是在艺术品、游戏内物品及其他独一无二资 产的代表上。这一需求催生了如ERC-721这样的非同质化代币标准。然而，单一的同质化或非同质化代币标准难以满 足市场对于更复杂、更灵活资产表示方式的需求。正是在这样的背景下，Dora-ERC404代币标准诞生了。</p>
</div>
</div>
</div>
</div>
</div>
<div class="page" title="Page 3">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>Dora-ERC404的设计初衷是整合同质化代币和非同质化代币的特点，为市场提供一种新的代币类型—半同质化代币。 这种代币能够根据特定条件或用户需求，改变自身的属性，从而实现同质化与非同质化的无缝过渡。在Dora-ERC404 出现之前，并没有一种代币能同时拥有这两种属性，这使得Dora-ERC404一经推出，便在行业内引起了广泛关注和讨 论。</p>
<p>Dora-ERC404标准的提出时间并不确定，但它作为概念的提出很可能是在ERC-721标准获得广泛认可之后，这一时期 区块链技术正在经历快速的创新和多样化发展。Dora-ERC404的早期版本在技术社区内部进行了小范围的讨论和迭 代，通过开发者和技术贡献者的共同努力，该标准逐渐成型并被更广泛地认识和接受。</p>
<p>尽管Dora-ERC404是基于社区共识和开放贡献的，但它的发展历程并非没有挑战。作为一项创新的尝试，Dora-ERC404 在被社区接受的过程中，需要克服技术实现的复杂性、潜在的安全性问题以及如何与现有区块链基础设施和标准融合 的障碍。但由于其所提供的独特价值和解决的实际问题，该标准逐渐获得了开发者社区和早期项目采纳者的支持。</p>
<p>随着时间的推移，Dora-ERC404在实际应用场景中展示了其潜力。从艺术品的数字化、游戏中虚拟物品的交易，到复 杂金融产品的代表，Dora-ERC404标准都显示出了其独特的灵活性和效用。尤其是在艺术和娱乐领域，Dora-ERC404使 得数字资产的所有权和转移变得更加丰富和有意义。对于艺术创作者、收藏家以及游戏玩家来说，Dora-ERC404提供 了一种全新的方式来创建、持有和交易他们的数字资产。</p>
<p>Dora-ERC404的发展也证明了开放式创新和社区驱动发展模式在区块链技术进步中的重要作用。通过持续的技术改进 和优化，Dora-ERC404不仅在早期的区块链爱好者和技术人员之间获得了一致好评，也开始受到更广泛的市场和主流 投资者的关注。随着数字资产领域的迅猛发展和更多行业的加入，Dora-ERC404将继续发挥其在促进资产代表性、可 交换性和创新性方面的作用。</p>
<p>以太坊(Ethereum)，作为一个开源的区块链平台，为去中心化应用(DApps)提供了运行环境。它的创新在于引入 了智能合约(Smart Contracts)的概念，这些自动执行的代码片段使得在无需第三方中介的情况下，用户可以创建复杂 的去中心化和自动化的应用。以太坊的网络架构和支持的智能合约模型，为包括Dora-ERC404在内的各种代币标准的 实现和运行提供了必要的基础设施。</p>
<p>以太坊网络是建立在一系列互联互通的节点上，每个节点都保存着整个以太坊区块链的复制版本。区块链是一种分布 式数据库，以连锁的区块形式存储数据，其中包含了一系列交易记录。新的交易或智能合约的操作被打包进新的区块 中，而创建新区块的过程称为挖矿。矿工通过解决复杂的密码学问题来竞争新区块的创建权，成功的矿工将新区块加 入区块链，并由网络达成共识，最终确认新区块的有效性。</p>
<p>以太坊网络内的每个动作，无论是普通交易还是智能合约的执行，都需要消耗一定量的“Gas”。Gas是对执行操作所需 计算资源的量度，通过以太坊的本地货币——ETH来支付。Gas费用旨在防止网络过载，并激励矿工验证和执行交易。</p>
<p>智能合约是以太坊区块链上的一段自执行的代码，它定义了合约的参与方之间的规则和协议。一旦智能合约被部署到 区块链上，就会自动执行，而且无法更改或删除，这保证了操作的不可逆性和透明性。以太坊上的智能合约使用 Solidity或Vyper等专用编程语言编写，智能合约的每一个功能都可以通过网络发出的交易来触发。</p>
<p>代币标准，例如Dora-ERC404，就是在智能合约的框架下定义的。这些标准规定了代币的创建、管理和交易等功能， 并确保它们与以太坊网络上的其他合约和服务兼容。ERC-20作为同质化代币的标准模型，为诸多加密货币和数字资产 提供了一种简单有效的表示形式。ERC-721标准则为非同质化代币(NFTs)奠定了基础，使得能够以区块链上唯一、 不可互换的方式表示资产。Dora-ERC404作为一种更进一步的尝试，它融合了ERC-20和ERC-721的特性，旨在创建半 同质化代币，这些代币可以根据特定的条件从同质化与非同质化之间转换。</p>
<p>Dora-ERC404标准的实现依赖于以太坊智能合约的灵活性。通过智能合约，Dora-ERC404代币的属性可以被设定为在满 足特定条件时发生转变。例如，一个ERC404代币可以作为活动票务系统中的入场券，在活动开始前作为同质化代币进 行交易，而活动一旦开始，每一张入场券则拥有独特的座位信息，成为非同质化代币。</p>
</div>
</div>
</div>
</div>
</div>
<div class="page" title="Page 4">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>以太坊不仅支持代币标准的运行，其去中心化特性和智能合约的复杂度还使得它能够承载各类去中心化金融(DeFi) 应用、游戏、艺术品拍卖等多种基于区块链的服务。这些应用案例凸显了以太坊网络的强大能力，同时也推动了诸如 Dora-ERC404这样新型代币标准的创新和发展。</p>
<p>以太坊正在经历不断的迭代和升级，以提高网络的可扩展性、安全性和性能。例如，以太坊2.0的升级旨在引入权益证 明(Proof of Stake，PoS)共识机制，以减少能源消耗并提高交易速度。这样的升级将为ERC404等新兴代币标准提供 更稳定、更高效的运行环境。</p>
<p>总体而言，以太坊平台提供了一个强大且多样化的生态系统，使得包括Dora-ERC404在内的多种代币标准得以发展。 随着技术的进步和社区的共同努力，我们可以期待在以太坊网络上出现更多具有创新性和实用性的代币解决方案。</p>
<p>非同质化代币(NFT)是一种独特的数字资产，它在区块链技术中代表着不可替代和唯一性。NFT的核心特征在于， 每个代币都是独一无二的，拥有独特的标识符，无法与任何其他代币等量交换。这与加密货币和ERC-20类型的同质化 代币截然不同，后者的每个单位都是可互换的，拥有等同的价值和功能。</p>
<p>NFT的定义:</p>
<p>非同质化代币，或简称NFT，是建立在区块链技术之上的一种特殊代币类型。它们通常存储在智能合约中，并与数字 文件(例如艺术作品、音乐、视频或其他形式的创意内容)相联系。NFT的独特之处在于它们的不可交换性，这意味 着每个NFT都含有独特的信息和属性，确保了其独一无二的身份。</p>
<p>NFT的特点: 不可互换性(Non-Fungibility):NFT的核心属性是其不可互换性，每个代币都带有独特的属性和标识，使其与其他代</p>
<p>币不同。</p>
<p>真实性与稀缺性(Authenticity and Scarcity):NFT由于区块链技术的加持，其所有权和来源都是可验证的，保证了它 们的真实性和稀缺性。</p>
<p>所有权证明(Proof of Ownership):NFT的持有者拥有区块链上可验证的所有权证明，这使得NFT成为了一个强有力 的数字所有权工具。</p>
<p>永久性(Permanence):一旦NFT被铸造，其数据就会永久记录在区块链上。除非原始创建者设置了可变更的属性， 否则NFT的主要属性不可更改。</p>
<p>可编程性(Programmability):与智能合约一样，NFT可以进行编程，以实现复杂的交互和功能，例如增加版税机 制，使原创者每次转售时都能获得收益。</p>
<p>交互性(Interoperability):NFT可以在支持相同标准的不同区块链平台上使用和交易，例如ERC-721和ERC-1155是以 太坊上普遍使用的NFT标准。</p>
<p>NFT与ERC-20的主要区别: ERC-20代币是以太坊上最广为人知的一种代币标准，它定义了一种同质化的代币，意味着这类代币的每个单位都是相</p>
<p>同的，可互换的。这类代币经常用于代表货币、积分系统或其他需要大量同类型资产的场景。 与之对比，NFT(例如按照ERC-721或ERC-1155标准发行的代币)代表着独特的资产或权益，不能被简单分割或等量</p>
<p>交换。每个NFT都有独立的价值，通常与其独特性、稀缺性和相关数字资产的内容价值相关联。</p>
<p>NFT赋予了数字内容真实的所有权和证明，这在艺术品收藏、游戏资产、身份验证等领域带来了颠覆性的变化。在 ERC-20同质化代币中，所有的代币在功能和价值上是等同的，而NFT则打破了这一局限，让每个代币都能代表一个独 立且不可替代的实体或概念。</p>
</div>
</div>
</div>
</div>
</div>
<div class="page" title="Page 5">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>Dora-ERC404的提出，是对传统NFT标准如ERC-721和ERC-1155的一种补充和扩展。在传统的NFT生态中，每个代币 都是唯一的，代表了一份不可分割的资产或权益。然而，Dora-ERC404引入了更加灵活的代币属性，使得NFT不再仅 仅是静态的、单一的资产表示。Dora-ERC404标准的推出，为NFT市场注入了新的活力，提高了NFT的应用范围和流 动性，并推动了NFT标准化的进程。</p>
<p>在Dora-ERC404的体系下，非同质化代币可以根据预设的条件或用户的需求，实现从非同质状态向同质状态的转换， 或相反。这种转换的可能，为NFT带来了前所未有的灵活性和动态性。在实际应用场景中，这意味着一种代币在特定 时间或条件下，可以充当通用货币或代表特定的权益和资产，从而扩展了NFT在游戏、艺术品、票务、会员权益等多 个领域中的应用。</p>
<p>通过Dora-ERC404，开发者能够设计出既可以作为收藏品交易，也可以用于特定功能的NFT。例如，在数字艺术领 域，一个代表艺术品的NFT可以在艺术品的所有权转移时，作为非同质化代币存在;而当艺术品被用于某个数字画廊 的订阅服务时，则可以转换为同质化的代幣。这种变化不仅简化了NFT的使用流程，也让数字资产的所有者能够灵活 地将其投入到不同的经济活动中。</p>
<p>Dora-ERC404的引入还带动了NFT的流动性和市场效率。传统NFT因其唯一性而难以实现快速的交易和流通。然而， 当NFT通过Dora-ERC404能在特定情景下转换为同质化代幣时，它们就可以更容易地在不同用户之间转移，增加了交 易的机会。这不仅促进了二级市场的繁荣，也为NFT持有者提供了更多变现的渠道。</p>
<p>此外，Dora-ERC404对NFT标准化的推动作用不可小觑。在它之前，NFT的标准化尚未形成统一的格局，ERC-721和 ERC-1155虽然被广泛接受，但在功能性和互操作性上仍然存在限制。Dora-ERC404的出现，为NFT的标准化提供了一 种全新的方向，强调了标准在适应不同场景下的重要性，为市场提供了一种更为灵活和通用的NFT定义。</p>
<p>在Dora-ERC404推动下的NFT标准化，不仅限于提升NFT的通用性和适用性，它还强调了智能合约的作用。通过在智 能合约中编写条件，Dora-ERC404可以实现复杂的逻辑操作，使得NFT不再是简单的所有权证明，而是可以执行具体 功能的动态资产。例如，一个NFT可以根据时间或其他触发条件自动转变其属性，或在满足特定条件后自动执行合约 内设定的行动，极大地增加了NFT的实用性和交互性。</p>
<p>在总体上，Dora-ERC404的出现，为NFT市场带来了新的机遇和挑战。它通过提供一种更为灵活和动态的代币标准， 推动了NFT从单一用途向多元化应用的转变，提升了NFT的流动性和市场参与度。这不仅仅是对NFT领域的一次技术 更新，更是对当前数字经济模式的一次重要革新。随着Dora-ERC404标准的不断发展和应用，我们可以预见一个更加 活跃和多元的NFT市场即将到来。</p>
<p>Dora-ERC404标准自推出以来，便以其灵活性和多功能性在众多应用场景中崭露头角。以下是Dora-ERC404在实际项目 中的一些应用案例，这些案例展示了该标准如何为用户和开发者开拓新机遇。</p>
<h4><strong>案例一:游戏行业的虚拟资产 </strong></h4>
<p>在游戏行业，Dora-ERC404标准被用来创造可以在游戏内部流通的虚拟物品和货币。传统的游戏物品往往是非同质化 的(NFT)，每个物品独一无二，不能互换。而Dora-ERC404允许这些游戏物品在必要时转化为同质化代币(FT)， 从而使它们能够在游戏的内部市场上自由交易，就如同游戏币一样。例如，在一款名为“幻境探险”的角色扮演游戏 中，玩家获得的独特装备可以在不战斗时转换为一种通用的游戏币，这种游戏币可以用来购买其他装备或者与其他玩 家交易。</p>
<h4>案例二:艺术品与版权管理</h4>
<p>Dora-ERC404为艺术家提供了一种创新的版权管理方式。艺术品可以以NFT的形式存在，以确保其独特性和版权归 属。同时，通过Dora-ERC404，艺术品可以授权给数字画廊或在线平台，期间这些NFT可以暂时转化为同质化代币， 允许用户按次访问或订阅。当艺术家需要展览或转售艺术品时，这些代币又可以轻松转换回NFT。这一模式不仅为艺 术家提供了新的展示和收入渠道，也让艺术爱好者更方便地接触到作品。</p>
</div>
</div>
</div>
</div>
</div>
<div class="page" title="Page 6">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column">
<h4>案例三:会员权益与服务</h4>
<p>Dora-ERC404为会员权益管理带来了便利。在一个线上健身平台中，会员可购买包含训练课程和个人指导的会员卡， 这些会员卡作为NFT发行，代表了用户对服务的独家访问权。用户在不使用服务时，可以将这些NFT会员卡转换为同 质化的代币，将它们出售给其他用户，或者在平台上兑换其他服务。这一过程不仅使会员权益流通性大增，还极大地 增加了会员服务的灵活性。</p>
<h4>案例四:数字身份验证</h4>
<p>在数字身份和数据隐私方面，Dora-ERC404提供了一种新的解决方案。一家在线身份验证公司使用Dora-ERC404标准来 发行可验证的身份代币。用户通过验证程序获得这些NFT，它们代表着用户的身份和信用度。当用户需要在不同的服 务平台上验证身份时，这些NFT就可以转换成一次性的同质化验证代币，用于完成验证过程，之后再转换回非同质化 状态，确保用户隐私。</p>
<h4>案例五:票务系统</h4>
<p>在票务系统中，Dora-ERC404同样展现出巨大潜力。一家电影院链推出基于Dora-ERC404的电影票，这些票在初始阶段 作为NFT出售，每张票都有唯一的坐位信息和观影时间。在观影日之前，用户可以将这些电影票转换为通用的同质化 代币，通过这种方式，用户可以在电影院的生态系统内自由交换电影票，甚至可以用来购买店内的食品和商品。这种 灵活性极大地提升了用户体验，也简化了电影院的票务管理。</p>
<p>通过以上应用案例，我们可以看出Dora-ERC404标准的潜力和多样性。它不仅为现有的数字资产提供了新的操作模 式，也为开发者创造了新的机会，使他们能够设计出功能更全面、更能满足市场需求的产品。随着区块链技术的不断 发展，我们可以期待Dora-ERC404将在未来的数字经济中扮演更加重要的角色。</p>
<p>随着区块链技术的不断进步和数字资产市场的日渐成熟，Dora-ERC404标准的发展前景广阔。它的设计理念和技术实 现为未来的应用打下了坚实的基础，预计将在以下几个方面发挥重要作用:</p>
<pre>一、增强数字资产的流动性与互操作性
</pre>
<p>当前，区块链领域中的资产通常分为两类:同质化代币(FTs)和非同质化代币(NFTs)，各自具有不同的属性和适 用场景。然而，Dora-ERC404的推出，将二者的优势结合在一个框架之下，能够根据需要灵活转换代币类型，从而极 大增加了资产的流动性。在不久的将来，Dora-ERC404标准有望成为一种通用的数字资产桥梁，使得不同类型资产间 的交易和利用更加便捷，推动整个区块链生态系统的互操作性和协同工作。</p>
<pre>二、多样化的金融产品创新
</pre>
<p>金融行业对区块链技术的兴趣日益浓厚，众多金融机构正在寻求利用区块链创建新型的金融产品。由于Dora-ERC404 能够在同质与非同质之间自如转换，未来的金融产品将可能出现全新的设计，如将债权、股权或其他金融工具设计为 既可以像股票或货币一样流通，同时又能保留特定权益的凭证。这将引发金融创新的新浪潮，进而激活资本市场，带 动新的经济增长点。</p>
<pre>三、扩展游戏与娱乐产业的边界
</pre>
<p>在游戏和娱乐行业，NFT已经开始发挥作用，玩家能够收集和交易虚拟物品。Dora-ERC404标准为游戏内资产的流通 提供了新的可能，不仅能提高玩家对于游戏内资产的控制，还能推动虚拟资产外部市场的形成。在未来，可以预见到 更多基于Dora-ERC404的游戏和娱乐平台出现，它们将利用这一标准带来的灵活性和便利性，构建跨游戏的经济系统 和玩家社区。</p>
<pre>四、促进数字艺术及版权管理的革新
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="page" title="Page 7">
<div class="section">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>Dora-ERC404标准对于艺术界特别是数字艺术市场的影响不容忽视。它为艺术家提供了新的方式来确保作品的原创 性，同时也为作品的销售和展示提供了更多元化的途径。数字艺术品可以通过Dora-ERC404实现从独一无二的作品到 可供多人欣赏或使用的商品之间的无缝转换，大幅提升了艺术品的市场接受度和流通性。</p>
<pre>五、激发去中心化身份认证和数据隐私的新模式
</pre>
<p>去中心化身份认证是未来数字经济中的关键一环。Dora-ERC404标准在身份验证和个人数据隐私方面有着巨大的应用 潜力，它能够使得用户的身份证明在需要时转换为同质化代币，简化身份验证流程，增强用户隐私保护，推动构建信 任的去中心化网络。</p>
<pre>六、推动票务和认证系统的转型
</pre>
<p>Dora-ERC404标准有望在票务和证书领域引发变革。票券作为NFT发行时具有独特性和不可替代性，但转化为同质化 代币后，可以在更大范围内流通和交易。从活动门票到学历证书，未来各种形式的证明都可以通过Dora-ERC404实现 更高效的发行、管理和转移，大大提高系统效率和用户便利性。</p>
<p>随着区块链技术的演进和普及，预期Dora-ERC404标准将在数字经济中扮演越发重要的角色。不断的探索和应用将使 其成为未来数字资产与区块链行业发展的一个关键推动因素。</p>
<p>在深入分析了Dora-ERC404标准及其特性后，我们可以清晰地认识到它在以太坊和NFT领域中的独特价值和重要性。 Dora-ERC404不仅创造了一种新的数字资产类型，它的出现也是对现有资产类别的一次重大扩展，这在以太坊区块链 上是前所未有的。</p>
<p>Dora-ERC404的核心创新是将同质化代币(FTs)和非同质化代币(NFTs)的属性融合于一体，这一点是以前代币标准 所不具备的。通过实现两者之间的自由转换，它极大地提高了资产的流动性，并且拓宽了代币的适用场景。对于那些 需要在不同状态下转换其属性的资产，Dora-ERC404提供了理想的解决方案。</p>
<p>在以太坊网络上，Dora-ERC404借助智能合约的强大功能，确保了在转换过程中代币安全性和独特性的维持。这对于 那些希望通过区块链技术提升其业务效率和安全性的组织来说，无疑是一个吸引人的优点。Dora-ERC404通过创新的 技术实现，提供了一种更加灵活、可靠的数字资产管理方式。</p>
<p>此外，Dora-ERC404对于金融产品创新而言也具有巨大潜力。它开辟了设计新型金融工具和服务的可能性，使得从资 产证券化到复杂的衍生品设计，都可以在此基础上进行开发。这为金融机构和创新者提供了一个能够实现资本和资源 更有效配置的平台。</p>
<p>游戏和娱乐产业也是Dora-ERC404重要的应用领域。在这一领域中，代币需要具备易于交易和转移的特性。Dora- ERC404标准所带来的资产流通性和互操作性，能够推动游戏内外部市场的形成和发展，助力构建更为广泛的虚拟经济 体系。</p>
<p>在数字艺术领域，Dora-ERC404则显得尤为重要。它不仅保护了艺术家的版权，还为作品的传播和销售提供了新的途 径。艺术家和创作者能够通过这一标准更好地控制作品的分发，并且通过资产的多样化能够触达更广泛的受众。</p>
<p>Dora-ERC404还促进了身份验证和数据隐私保护领域的进步。在去中心化身份验证方面，Dora-ERC404提供了一种安全 可靠的方式，使得个人信息在必要时能够被验证，同时保持用户隐私的保护。</p>
<p>最后，Dora-ERC404在票务和认证系统中也展现了其转型潜力。从体育赛事门票到专业资格证书，Dora-ERC404都为这 些场景提供了更为高效的处理和流转方式。</p>
<p>综上所述，Dora-ERC404不仅为数字资产的定义和流转提供了新的视角，而且通过它的多功能性、灵活性，以及与以 太坊网络的兼容性，为区块链行业带来了实质性的创新。随着区块链技术的持续进步和更广泛的应用，我们可以期待 Dora-ERC404在未来数字经济中将扮演更为关键和核心的角色，推动各行各业向前发展。</p>
</div>
</div>
</div>
</div>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Consequentialism</title>
        <author>
            <name>scooorpion</name>
        </author>
        <link href="https://scooorpion.github.io/jie-guo-zhu-yi-consequentialism.html"/>
        <id>https://scooorpion.github.io/jie-guo-zhu-yi-consequentialism.html</id>
        <media:content url="https://scooorpion.github.io/media/posts/8/GG_8D9WaQAAc992.jpeg" medium="image" />
            <category term="Thought"/>

        <updated>2024-06-02T15:48:52+08:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://scooorpion.github.io/media/posts/8/GG_8D9WaQAAc992.jpeg" alt="" />
                    “结果，对人生体验来说很重要。要提前设计好结果的概率区间，和丰富自己对结果的解读能力，尽量让事情的结果落在自己能接受的区间里面“。 乍看这个道理，可能会觉得与“人生在于体验、人生在于经历”等过程学派的观点相悖。其实不然。 如果我们把人生看成一件件“事情”的总和，那么很多时候，同样付出了时间和努力，因为结果的不同，当我们回忆起“过程”时，整个回忆的色彩是截然不同的。&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://scooorpion.github.io/media/posts/8/GG_8D9WaQAAc992.jpeg" class="type:primaryImage" alt="" /></p>
                
  <p>
    <b>“结果，对人生体验来说很重要。要提前设计好结果的概率区间，和丰富自己对结果的解读能力，尽量让事情的结果落在自己能接受的区间里面“。</b><br><br>乍看这个道理，可能会觉得与“人生在于体验、人生在于经历”等过程学派的观点相悖。其实不然。<br><br>如果我们把人生看成一件件“事情”的总和，<b>那么很多时候，同样付出了时间和努力，因为结果的不同，当我们回忆起“过程”时，整个回忆的色彩是截然不同的。<br></b><br>比如，同样花了一个月的时间准备一个dream company的面试。如果最终进了，那么，那段披星戴月的时间会成为自己“光辉岁月”故事集里浓墨重彩的一篇；要是没进，回忆的时候则会带上悲凉、徒劳的色彩，甚至想到那个公司都会有种排斥。<br><br>同样的一件事，因为结果的不同，在我们记忆中呈现的景象，可以完全不同。而我们的幸福感，常常来源于事后回忆时，自己给自己编造的“故事”。<br><br>如果能把自己的一生frame为一个个有意义的基调正面的人生故事的总合，无疑会极大的提高我们的幸福感。<br><br>而具体怎么engineer one's life story呢？回到开头说的<b>“提前设计好结果的概率区间，和丰富自己对结果的解读能力，尽量让事情的结果落在自己能接受的区间里面“。</b><br><br>比如，做一件事情的时候，可以把预期设到最低，这样不管最终结果如何，回头看都是“达到目标”的success story。同时，也可以明确地告诉自己，做这件事的意义就是去“学习”、“试错“，这样的话，就算最终失败，这个失败也是落在了你可以接受的结果区间内的—— 毕竟，失败也是一种finding。这样的话，不管成功或失败，你那永不停歇的storytelling brain永远都能自圆其说，给你编一个积极的故事。<br><br>需知道，我们不是不能承受失败，而是哪怕失败、也得有策略的“失败”，不能累积无意义的挫败感，否则失败的阴影留在记忆中，一定会在未来继续它的负面影响。有技巧的设计和解读人生的“结果”，可以让所有的经历回头看都被自己的大脑定义为值得的、享受的、成功的。这种正面的“意义感“所带来的反馈则会引发正向的循环。<br><br>人的自我是很脆弱的。要在漫长的人生中保持相对积极的状态，需要有这种与自己“斡旋”的智慧。
  </p>

  <p>
    ——转自Iris Pan
  </p>
            ]]>
        </content>
    </entry>
</feed>
