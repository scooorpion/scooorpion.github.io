<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script><script type="text/javascript">window.MathJax = {
            tex: {
              inlineMath: [['$', '$'], ['\\(', '\\)']],
              displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
              skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
              ignoreHtmlClass: 'tex2jax_ignore',
              processHtmlClass: 'tex2jax_process'
            }
          };</script><title>Swift Notes - FX</title><meta name="description" content="Basic 打印常量和变量 Printing&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><script async defer="defer" type="text/javascript" src="https://cloud.umami.is/script.js" data-website-id="04439f08-d145-4e0d-9dec-94051ae08e3a" data-auto-track="true" data-do-not-track="false" data-cache="false"></script><meta name="theme-color" content="#17181E" media="(prefers-color-scheme: dark)"><meta name="theme-color" content="#FFFFFF" media="(prefers-color-scheme: light)"><meta name="msapplication-navbutton-color" content="#FFFFFF"><meta name="apple-mobile-web-app-status-bar-style" content="#FFFFFF"><link rel="stylesheet" href="https://scooorpion.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://scooorpion.github.io/swift-notes.html"><link rel="alternate" type="application/atom+xml" href="https://scooorpion.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://scooorpion.github.io/feed.json"><link rel="preload" href="https://scooorpion.github.io/assets/dynamic/fonts/publicsans/publicsans.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://scooorpion.github.io/assets/css/style.css?v=d0bc1c9147eb8b28e5a8548bf6af85a5"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://scooorpion.github.io/swift-notes.html"},"headline":"Swift Notes","datePublished":"2024-07-16T20:51","dateModified":"2024-07-21T00:34","image":{"@type":"ImageObject","url":"https://scooorpion.github.io/media/posts/20/google-deepmind-RO_I_35SX7c-unsplash.jpg","height":7680,"width":7680},"description":"Basic 打印常量和变量 Printing&hellip;","author":{"@type":"Person","name":"scooorpion","url":"https://scooorpion.github.io/authors/scooorpion/"},"publisher":{"@type":"Organization","name":"scooorpion"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><style>.fi{fill:none;stroke-linecap:round;stroke-linejoin:round;vertical-align:middle}</style></head><body><div class="content content--nosidebar"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://scooorpion.github.io/">FX</a><nav class="navbar"><button class="navbar__toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle__box"><span class="navbar__toggle__inner">Menu</span></span></button><ul class="navbar__menu"><li class="tltp tltp--top"><a class="tltp" href="https://scooorpion.github.io/" target="_self" aria-label="Home"><svg class="fi fi-home" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://scooorpion.github.io/media/plugins/featherIcons/feather-sprite.svg#home"/></svg> <span>Home</span></a></li><li class="tltp tltp--top"><a class="tltp" href="https://scooorpion.github.io/tags/" target="_self" aria-label="Pages Tag"><svg class="fi fi-tag" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://scooorpion.github.io/media/plugins/featherIcons/feather-sprite.svg#tag"/></svg> <span>Pages Tag</span></a></li><li class="tltp tltp--top"><a class="tltp" href="https://scooorpion.github.io/photos-gallery.html" target="_self" aria-label="Photos"><svg class="fi fi-camera" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://scooorpion.github.io/media/plugins/featherIcons/feather-sprite.svg#camera"/></svg> <span>Photos</span></a></li><li><a class="tltp" href="https://gaokao.vercel.app" target="_blank" aria-label="Gaokao"><svg class="fi fi-arrow-up-right" width="24px" height="24px" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><use href="https://scooorpion.github.io/media/plugins/featherIcons/feather-sprite.svg#arrow-up-right"/></svg> <span>Gaokao</span></a></li></ul></nav><a class="logo logo--atbottom" href="./">FX</a></header></div></div><main class="main"><article class="post"><figure class="post__featured-image post__featured-image--attop"><img src="https://scooorpion.github.io/media/posts/20/google-deepmind-RO_I_35SX7c-unsplash.jpg" srcset="https://scooorpion.github.io/media/posts/20/responsive/google-deepmind-RO_I_35SX7c-unsplash-xs.webp 320w, https://scooorpion.github.io/media/posts/20/responsive/google-deepmind-RO_I_35SX7c-unsplash-sm.webp 480w, https://scooorpion.github.io/media/posts/20/responsive/google-deepmind-RO_I_35SX7c-unsplash-md.webp 768w, https://scooorpion.github.io/media/posts/20/responsive/google-deepmind-RO_I_35SX7c-unsplash-xl.webp 1024w" sizes="(min-width: 1460px) 938px, (min-width: 1200px) calc(75.83vw - 154px), (min-width: 1120px) 938px, (min-width: 900px) calc(55vw + 333px), 100vw" loading="eager" height="7680" width="7680" alt="" aria-describedby="image-caption"></figure><div class="post__meta post__meta--attop"><div class="post__meta--attop__inner"><div class="post__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://scooorpion.github.io/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://scooorpion.github.io/tags/swift/" class="metadata__maintag">Swift</a></div></div></div><div class="main__inner"><div class="post__meta"><div class="post__author"><img src="https://scooorpion.github.io/media/website/141690554149_.pic.jpg" loading="lazy" height="695" width="720" alt="scooorpion" class="post__author__avatar"><div><a href="https://scooorpion.github.io/authors/scooorpion/" class="post__author__name">scooorpion</a></div></div><div class="post__date"><time datetime="2024-07-16T20:51">Jul 16, 2024</time></div></div><header class="post__header"><h1 class="post__title">Swift Notes</h1><p class="post__lead">一些关于Swift6 和SwiftUI 的笔记</p></header><div class="post__entry"><h2 id="basic">Basic</h2><h3 id="打印常量和变量-printing-constants-and-variables">打印常量和变量 <em>Printing Constants and Variables</em></h3><p><code>print(_:separator:terminator:)</code></p><ul><li><code>separator</code> : 用于分隔</li><li><code>terminator</code> : 用于结尾</li><li>字符串插值（string interpolation）：<code>&quot;\(value)&quot;</code></li></ul><h3 id="decimal">Decimal</h3><ul><li><p>四则运算一定要同类型，否则会造成精度缺失或者一些更严重的问题。</p></li><li><p>0.1 + 0.2 != 0.3</p><p>计算机内部使用二进制来表示浮点数，而二进制无法精确表示十进制的小数点后无限位的数值。 具体来说，十进制小数 <code>0.1</code> 在二进制中是一个无限循环小数。二进制中没有直接的表示方法来精确表示 <code>0.1</code>，因此计算机使用最接近的浮点数表示来近似它。同样，<code>0.2</code> 也是一个无法精确表示的十进制小数，在二进制中有类似的近似问题。 当你把两个这样的近似值相加时，结果会受到这种近似的影响，产生一个稍微大于 <code>0.3</code> 的值。这是浮点数精度问题的一个常见例子，也是为什么在涉及浮点数的比较时，经常需要设置一个误差范围（或者使用特定的数学库来处理高精度的小数运算）。</p><p>在Swift中，你可以使用 <code>Double</code> 类型来进行浮点数运算，但是由于其内部表示的限制，你可能会遇到这种精度问题。如果你需要更精确的小数运算，可以考虑使用 <code>Decimal</code> 类型，它提供了更高的精度，但相应的也会消耗更多的内存和计算资源。</p></li></ul><p><code>Decimal</code> 需要 <strong>Foundation</strong> Framework，是一个可选类型（Optional）,你不能保证这个数字一定能转化成功</p><pre><code class="language-swift">import Foundation

import Foundation 
let decimal: Decimal = 1 
let decimal2 = Decimal（1）
let decimal3: Decimal = 3.24 //这个写法是有问题的，因为相当于在Decimal中存了一个Double
print（decima13）//3.2400000000003

let decimal4 = Decimal（string： &quot;hel1o&quot;）//
print（decima14）//nil
</code></pre><blockquote><p>Decimal 类型用于表示高精度的十进制数。由于直接将浮点数（如 Double）转换为 Decimal 可能会导致精度问题，因此需要使用字符串初始化 Decimal 以避免这种问题。</p></blockquote><pre><code class="language-swift">let a = Decimal（string： &quot;0.1&quot;）！ 
let b = Decimal（string： &quot;0.2&quot;）！
print（a + b） //0.3

//address the issue right?
</code></pre><h3 id="character--string-字符与字符串">Character &amp; String 字符与字符串</h3><p>在 Swift 中 <code>String</code> 类型是<em>值类型</em>。如果你创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。在前述任一情况下，都会对已有字符串值创建新副本，并对该新副本而非原始字符串进行传递或赋值操作。值类型在 <a href="https://gitbook.swiftgg.team/swift/swift-jiao-cheng/09_structures_and_classes#structures-and-enumerations-are-value-types">结构体和枚举是值类型</a> 中进行了详细描述。</p><blockquote><p><em>值类型</em>是这样一种类型，当它被赋值给一个变量、常量或者被传递给一个函数的时候，其值会被<em>拷贝</em>。</p><p>在之前的章节中，你已经大量使用了值类型。实际上，Swift 中所有的基本类型：整数（integer）、浮点数（floating-point number）、布尔值（boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，其底层也是使用结构体实现的。</p></blockquote><h4 id="扩展字符串分隔符">扩展字符串分隔符</h4><p>您可以将字符串文字放在扩展分隔符中，这样字符串中的特殊字符将会被直接包含而非转义后的效果。将字符串放在引号（<code>&quot;</code>）中并用数字符号（<code>#</code>）括起来。例如，打印字符串文字 <code>#&quot;Line 1 \nLine 2&quot;#</code> 会打印换行符转义序列（）而不是给文字换行。</p><pre><code class="language-swift">print(#&quot;Line 1 \nLine 2&quot;#)
//结果：Line 1 \nLine 2
</code></pre><p>如果要在使用扩展字符串分隔符的字符串中使用字符串插值，需要在反斜杠后面添加与开头和结尾数量相同扩展字符串分隔符。例如：</p><pre><code class="language-Swift">print(#&quot;6 times 7 is \#(6 * 7).&quot;#)
// 打印 &quot;6 times 7 is 42.&quot;
</code></pre><blockquote><p>注意</p><p>插值字符串中写在括号中的表达式不能包含非转义反斜杠（<code>\</code>），并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p></blockquote><h4 id="unicode">Unicode</h4><p><code>Character</code>由Unicode组成，<code>String</code> 由 <code>Character</code>组成</p><p>每一个 Swift 的 <code>Character</code>类型代表一个<em>可扩展的字形群 (Extended Grapheme Clusters)</em>。而一个可扩展的字形群构成了人类可读的单个字符，它由一个或多个（当组合时） Unicode 标量的序列组成。</p><p>具体来说，一个 String 可以包含一个或多个 Character，而每个 Character 可以包含一个或多个 Unicode 标量值。Swift 使用这种方式来确保字符串操作的正确性和一致性。</p><p>举个例子，String 的存储细节：</p><pre><code>你好棒👍 =&gt; 20320 22909 26834 128077 127998
</code></pre><blockquote><p>一个工具叫zalgo text文字生成器，可以随机组合Unicode生成一些乱码的文字</p></blockquote><p>在 Swift 中，当你操作字符串（比如连接或修改字符串）时，即使涉及到可扩展的字形群集，字符串的字符数量（Character 的数量）可能不会改变。这是因为 Character 代表的是一个完整的可扩展字形群集，而不仅仅是单个的 Unicode 标量值。</p><p>也就是说，当你使用<code>.count</code>属性计算一个 <code>String</code> 的长度时，计算的数字不是 Unicode 标量值（Unicode Scalar）的数量，而是字符串中可视字符（即 Character）的数量。</p><h4 id="四舍五入小数">四舍五入小数</h4><pre><code class="language-swift">let number = 123124.74023402394 

import Foundation 
let formatter = NumberFormatter()
formatter.maximumFractiohDigits = 2
print(formatter.string(for: number)!)
</code></pre><h3 id="enum-枚举声明">Enum 枚举声明</h3><p>你可以用Bool处理有两种可能性的东西，但是当一种东西不只有两种可能性，你可以用<code>enum</code>，比如<del>美国人的性别</del>但是，当然，任然是有限种选择。</p><p>Optional也是一种enum</p><h3 id="range">Range</h3><h3 id="三元条件运算符-ternary-conditional-operator">三元条件运算符 <em>ternary conditional operator</em></h3><p>三元<em>条件运算符</em>是一种特殊的运算符，由三部分组成，形式为<code>question ? answer1 : answer2</code>。</p><p>如果<code>question</code>为真，则评估<code>answer1</code>并返回其值；否则，评估<code>answer2</code>并返回其值。</p><p>三元条件运算符是以下代码的简写：</p><pre><code class="language-swift">if question {
    answer1
} else {
    answer2
}
</code></pre><h3 id="元组-tuples--类型别名-type-aliases">元组 <em>Tuples</em> &amp; 类型别名 <em>type aliases</em></h3><p><em>元组（tuples）</em> 把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p><blockquote><p>可以减去命名变量的痛苦，</p></blockquote><pre><code class="language-swift">let http404Error = (404, &quot;Not Found&quot;)
// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)
//http404Error.0 == 404
//http404Error.1 == &quot;Not Found&quot;
</code></pre><p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 <code>(Int, Int, Int)</code> 或者 <code>(String, Bool)</code> 或者其他任何你想要的组合的元组。</p><h4 id="元组分解（decompose）">元组分解（decompose）:</h4><pre><code class="language-swift">let (statusCode, statusMessage) = http404Error
print(&quot;The status code is \(statusCode)&quot;)
// 输出“The status code is 404”
print(&quot;The status message is \(statusMessage)&quot;)
// 输出“The status message is Not Found”
</code></pre><p>你可以使用 <code>typealias</code> 关键字来定义类型别名。</p><p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p><pre><code class="language-swift">typealias AudioSample = UInt16
</code></pre><p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p><pre><code class="language-swift">var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound 现在是 0
</code></pre><p>本例中，<code>AudioSample</code> 被定义为 <code>UInt16</code> 的一个别名。因为它是别名，<code>AudioSample.min</code> 实际上是 <code>UInt16.min</code>，所以会给 <code>maxAmplitudeFound</code> 赋一个初值 <code>0</code>。</p><blockquote><p>你可以把Tuples当做一个简单的类型使用</p></blockquote><pre><code class="language-swift">typealias Human = （String, Double, String）
let man: Human = (&quot;A&quot;,10.2,&quot;B&quot;)// 建立了一个“Human类型&quot;，但其实本质上是一个元祖
</code></pre><h3 id="set--hashable">Set &amp; Hashable</h3><p>在 Swift 中，Hashable 是一种协议，类型可以遵循该协议以便在字典中用作键或存储在集合中。当一个类型遵循 Hashable 时，这意味着该类型的实例可以被哈希为 Int 类型的值，该值用于唯一标识该实例。</p><p><strong>Why Hashable?</strong></p><ul><li><strong>Dictionary Keys</strong>: When using a type as a key in a dictionary, the dictionary needs to quickly look up, add, and remove values. Hashing allows for efficient access.</li><li><strong>Set Elements</strong>: Sets rely on hashing to ensure that elements are unique and to quickly check for membership.</li><li><strong>Performance</strong>: Hashing provides constant-time complexity for operations like lookups, insertions, and deletions in hash-based collections.</li></ul><p>Hashing is a fundamental concept in computer science that provides efficient data retrieval, especially in hash-based collections like dictionaries and sets.</p><ul><li><strong>Hash Function</strong>: Transforms keys into hash values.</li><li><strong>Hash Table</strong>: Uses hash values to index and store key-value pairs.</li><li><strong>Collision Handling</strong>: Manages cases where multiple keys produce the same hash value.</li><li><strong>Efficiency</strong>: Direct indexing allows for constant-time complexity (O(1)) for insertions, deletions, and lookups on average.</li></ul><h4 id="how-hashing-works">How Hashing Works</h4><ol><li><p><strong>Hash Function</strong>: When an object (like a key in a dictionary) needs to be stored or retrieved, a hash function is applied to the object. This function computes a hash value (an integer) from the object’s data.</p></li><li><p><strong>Hash Table</strong>: This hash value is then used as an index to place the object in a hash table (an array). The hash table is a data structure that maps keys to values using the computed hash values.</p></li></ol><h4 id="ensuring-quick-lookups">Ensuring Quick Lookups</h4><ul><li><p><strong>Direct Access</strong>: Since the hash value directly maps to an index in the hash table, accessing the data can be done in constant time, O(1). This means that the time it takes to retrieve the value does not depend on the number of elements in the table.</p></li><li><p><strong>Uniform Distribution</strong>: A good hash function distributes hash values uniformly across the hash table, minimizing the number of collisions (when two different objects produce the same hash value).</p></li></ul><h4 id="handling-collisions-处理哈希碰撞">Handling Collisions 处理哈希碰撞</h4><p>Collisions are inevitable in hashing because different objects can produce the same hash value. However, efficient techniques exist to handle collisions:</p><ol><li><p><strong>Chaining</strong>: Each index in the hash table points to a linked list (or another collection) of entries that have the same hash value. When a collision occurs, the new entry is added to the list at that index. Lookup operations involve scanning the list, which is generally short if the hash function distributes values well.</p><pre><code class="language-plaintext">Hash Table (using chaining):
Index  | Entries
0      | [ ]
1      | [ ]
2      | [ ]
3      | [ &quot;Key1&quot; -&gt; &quot;Value1&quot;, &quot;Key2&quot; -&gt; &quot;Value2&quot; ]
4      | [ ]
</code></pre></li><li><p><strong>Open Addressing</strong>: When a collision occurs, the hash table looks for another open slot using a probing sequence (linear probing, quadratic probing, or double hashing). The lookup operation follows the same probing sequence to find the correct slot.</p><pre><code class="language-plaintext">Hash Table (using linear probing):
Index  | Entry
0      | [ ]
1      | [ ]
2      | [ &quot;Key2&quot; -&gt; &quot;Value2&quot; ]
3      | [ &quot;Key1&quot; -&gt; &quot;Value1&quot; ]
4      | [ ]
</code></pre></li></ol><h4 id="constant-time-complexity">Constant-Time Complexity</h4><p>Hashing ensures that the average time complexity for insertions, deletions, and lookups is O(1) under the following conditions:</p><ul><li><strong>Good Hash Function</strong>: A well-designed hash function that minimizes collisions and distributes keys uniformly.</li><li><strong>Load Factor Management</strong>: The load factor (number of entries divided by the number of slots in the hash table) is kept low by resizing the table when necessary (rehashing). This ensures that the number of entries in each slot remains small.</li></ul><p>一个类型为了存储在集合中，该类型必须是<em>可哈希化</em>的——也就是说，该类型必须提供一个方法来计算它的<em>哈希值</em>。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如 <code>a == b</code>,因此必须 <code>a.hashValue == b.hashValue</code>。</p><p>Swift 的所有基本类型（比如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希化的，可以作为集合值的类型或者字典键的类型。没有关联值的枚举成员值（在 <a href="https://gitbook.swiftgg.team/swift/swift-jiao-cheng/08_enumerations">枚举</a> 有讲述）默认也是可哈希化的。</p><p><code>Set</code>是一种遵照Hashable的类型，也就是数学中的集合，可以做集合运算，以及在集合中不能有重复的元素，所以很好理解，可以它声明为Hashable。</p><p>Swift 中的集合类型被写为 <code>Set&lt;Element&gt;</code>，这里的 <code>Element</code> 表示集合中允许存储的类型。和数组不同的是，集合没有等价的简化形式。</p><pre><code class="language-swift">var letters = Set&lt;Character&gt;()
print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;)
// 打印“letters is of type Set&lt;Character&gt; with 0 items.”
</code></pre><blockquote><p>注意</p><p>通过构造器，这里 <code>letters</code> 变量的类型被推断为 <code>Set&lt;Character&gt;</code>。</p></blockquote><p>一个集合类型不能从数组字面量中被直接推断出来，因此 <code>Set</code> 类型必须显式声明。然而，由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个集合并且与该数组字面量中的所有元素类型相同，那么无须写出集合的具体类型。<code>favoriteGenres</code> 的构造形式可以采用简化的方式代替：</p><pre><code class="language-swift">// Two ways to declare
var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
// favoriteGenres 被构造成含有三个初始值的集合

var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre><p>由于数组字面量中的所有元素类型相同，Swift 可以推断出 <code>Set&lt;String&gt;</code> 作为 <code>favoriteGenres</code> 变量的正确类型。</p><h4 id="集合的一些数学操作">集合的一些数学操作</h4><ul><li>使用 <code>intersection(_:)</code> 方法根据两个集合的交集创建一个新的集合。</li><li>使用 <code>symmetricDifference(_:)</code> 方法根据两个集合不相交的值创建一个新的集合。</li><li>使用 <code>union(_:)</code> 方法根据两个集合的所有值创建一个新的集合。</li><li>使用 <code>subtracting(_:)</code> 方法根据不在另一个集合中的值创建一个新的集合。</li></ul><pre><code class="language-Swift">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre><ul><li>使用“是否相等”运算符（<code>==</code>）来判断两个集合包含的值是否全部相同。</li><li>使用 <code>isSubset(of:)</code> 方法来判断一个集合中的所有值是否也被包含在另外一个集合中。</li><li>使用 <code>isSuperset(of:)</code> 方法来判断一个集合是否包含另一个集合中所有的值。</li><li>使用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code> 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li><li>使用 <code>isDisjoint(with:)</code> 方法来判断两个集合是否不含有相同的值（是否没有交集）。</li></ul><pre><code class="language-swift">let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]
let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]
let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre><h2></h2><h3 id="可选类型（optionals）">可选类型*（optionals）*</h3><p>可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。</p><p><strong>An Example:</strong></p><p>Swift 的 <code>Int</code> 类型有一种<em>构造器</em>，作用是将一个 <code>String</code> 值转换成一个 <code>Int</code> 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 <code>&quot;123&quot;</code> 可以被转换成数字 <code>123</code> ，但是字符串 <code>&quot;hello, world&quot;</code> 不行。</p><blockquote><p>构造器是一种特殊的函数，用于创建类、结构体或枚举的实例。它们不返回值，而是负责初始化实例的所有属性，并确保实例在第一次使用前处于有效状态。</p><pre><code class="language-swift">struct Person {
 var name: String
 var age: Int

 init(name: String, age: Int) { //就是构造函数
     self.name = name
     self.age = age
 }
}

let person = Person(name: &quot;John&quot;, age: 25)
</code></pre></blockquote><p>下面的例子使用这种构造器来尝试将一个 <code>String</code> 转换成 <code>Int</code>：</p><pre><code class="language-Swift">let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;
</code></pre><p>因为该构造器可能会失败，所以它返回一个 <em>可选类型</em> （optional）<code>Int</code>，而不是一个 <code>Int</code>。一个可选的 <code>Int</code> 被写作 <code>Int?</code> 而不是 <code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含 <code>Int</code> 值也可能 <em>不包含值</em> 。（不能包含其他任何值比如 <code>Bool</code> 值或者 <code>String</code> 值。只能是 <code>Int</code> 或者什么都没有。）</p><h4 id="nil">nil</h4><p>你可以给可选变量赋值为 <code>nil</code> 来表示它没有值：</p><pre><code class="language-Swift">var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre><blockquote><p>注意</p><p><code>nil</code> 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p></blockquote><p>如果你声明一个可选变量但是没有赋值，它们会自动被设置为 <code>nil</code>：</p><pre><code class="language-swift">var surveyAnswer: String?
// surveyAnswer 被自动设置为 nil
</code></pre><blockquote><p>注意</p><p>Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。</p></blockquote><h4 id="if-语句以及强制解析">if 语句以及强制解析</h4><p>你可以使用 <code>if</code> 语句和 <code>nil</code> 比较来判断一个可选值是否包含值。你可以使用“相等”(<code>==</code>)或“不等”(<code>!=</code>)来执行比较。</p><p>如果可选类型有值，它将不等于 <code>nil</code>：</p><pre><code class="language-swift">if convertedNumber != nil {
    print(&quot;convertedNumber contains some integer value.&quot;)
}
// 输出“convertedNumber contains some integer value.”
</code></pre><p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的 <em>强制解析（forced unwrapping）</em> ：</p><pre><code class="language-swift">if convertedNumber != nil {
    print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)
}
// 输出“convertedNumber has an integer value of 123.”
</code></pre><p>更多关于 <code>if</code> 语句的内容，请参考 <a href="https://gitbook.swiftgg.team/swift/swift-jiao-cheng/05_control_flow">控制流</a>。</p><blockquote><p>注意</p><p>使用 <code>!</code> 来获取一个不存在的可选值会导致运行时错误。使用 <code>!</code> 来强制解析值之前，一定要确定可选包含一个非 <code>nil</code> 的值。</p></blockquote><h2 id="函数">函数</h2><p>一些关于函数的概念：</p><ol><li><strong>形参（Formal Parameters 形式参数）</strong>：在函数定义中声明的参数，它们是函数内部使用的变量，用于接收传递给函数的值。</li><li><strong>实参（Actual Parameters 实际参数）</strong>：在函数调用时传递给函数的值，它们是实际的数据，用于初始化形参。</li><li><strong>返回类型</strong>：函数可以返回一个值，这个值的类型就是返回类型。如果函数不返回任何值，则返回类型为<code>void</code>。</li><li><strong>方法（Method）</strong>：在面向对象编程中，方法是与对象相关联的函数。它通常可以访问和操作对象的属性。</li><li><strong>属性（Property）</strong>：对象的属性是与对象状态相关的变量。在面向对象编程中，属性可以是变量或函数，用于表示对象的状态。</li></ol><blockquote><p>属性如何作为函数？在面向对象编程（OOP）中，属性可以被看作是对象的特征或状态，它们可以是简单的变量，也可以是通过计算得到的值，这就涉及到计算属性的概念。</p></blockquote><h3 id="函数参数名称与参数标签">函数参数名称与参数标签</h3><p>在Swift中，函数参数可以有两个名字：一个是参数标签（argument label），另一个是参数名称（parameter name）。参数标签在函数调用时使用，而参数名称在函数体内使用。</p><blockquote><p>有点绕，简单点说就是第一个<strong>参数标签</strong>用于调用的时候，第二个参数名称用于函数体里面用</p></blockquote><pre><code class="language-swift">func greet(person name: String) {
   //greet(参数标签 参数名称: String)
    print(&quot;Hello, \(name)!&quot;)
}

greet(person: &quot;Alice&quot;)
// 调用时使用参数标签 person
</code></pre><p>可以省略参数标签：</p><pre><code class="language-swift">func greet(_ name: String) {
    print(&quot;Hello, \(name)!&quot;)
}

greet(&quot;Alice&quot;)
// 这样就类似C++里面的调用方式
</code></pre><p><strong>参数标签和参数名称</strong></p><ul><li><strong>两个名称</strong>（参数标签和参数名称）：第一个名称是参数标签，用于函数调用时，第二个名称是参数名称，用于函数体内。</li><li><strong>一个名称</strong>（参数标签和参数名称相同）：如果只有一个名称，它既是参数标签，又是参数名称。</li></ul><pre><code class="language-swift">print(_: separator: terminator:)
//很明显这个separator就是参数标签==参数名称
</code></pre><h3 id="可变参数">可变参数</h3><p>一个*可变参数（variadic parameter）*可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（<code>...</code>）的方式来定义可变参数。</p><p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p><p>下面的这个函数用来计算一组任意长度数字的 <em>算术平均数（arithmetic mean)</em>：</p><pre><code class="language-Swift">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// 返回 3.0, 是这 5 个数的平均数。
arithmeticMean(3, 8.25, 18.75)
// 返回 10.0, 是这 3 个数的平均数。
</code></pre><p>一个函数能拥有多个可变参数。可变参数后的第一个形参前必须加上实参标签。实参标签用于区分实参是传递给可变参数，还是后面的形参。</p><p><code>print</code>中：</p><pre><code class="language-swift">func print(_ items: Any..., separator: String = &quot; &quot;, terminator: String = &quot;\n&quot;)
</code></pre><p>使用的<code>Any...</code>就表示可以用很多不同的类型，而且可以同时传入很多，(比如Int String Character etc.)</p><p><code>String = &quot; &quot;</code>这个是预设数值</p><h3 id="多重返回值函数">多重返回值函数</h3><p>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p><p>下例中定义了一个名为 <code>minMax(array:)</code> 的函数，作用是在一个 <code>Int</code> 类型的数组中找出最小值与最大值。</p><pre><code class="language-Swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int) { //多了一个(min: Int, max: Int)用于查询函数的返回值
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

//(currentMin, currentMax) -&gt; (min: Int, max: Int) 变量改为了上面所定义的min与max
</code></pre><p><code>minMax(array:)</code> 函数返回一个包含两个 <code>Int</code> 值的元组，这些值被标记为 <code>min</code> 和 <code>max</code> ，<strong>以便查询函数的返回值时可以通过名字访问它们。</strong></p><p>在 <code>minMax(array:)</code> 的函数体中，在开始的时候设置两个工作变量 <code>currentMin</code> 和 <code>currentMax</code> 的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比 <code>currentMin</code> 和 <code>currentMax</code> 更小或更大。最后数组中的最小值与最大值作为一个包含两个 <code>Int</code> 值的元组返回。</p><p><strong>因为元组的成员值已被命名</strong>，因此可以通过 <code>.</code> 语法来检索找到的最小值与最大值：</p><pre><code class="language-Swift">let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
// 打印“min is -6 and max is 109”
</code></pre><p>需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</p><h3 id="面向对象-oop-的哲学">面向对象 OOP 的哲学</h3><p>面向对象编程（OOP）是一种编程范式，强调将数据和操作数据的代码封装在一起，称之为“对象”。OOP的哲学在于模拟现实世界，通过对象和类来表示和组织程序。</p><h4 id="核心概念">核心概念</h4><ol><li><strong>对象（Object）</strong>：现实世界中的实体在程序中的抽象。对象具有属性（数据）和方法（行为）。</li><li><strong>类（Class）</strong>：对象的蓝图或模板。类定义了对象的属性和方法。</li><li><strong>封装（Encapsulation）</strong>：将数据和操作数据的方法封装在对象内部，隐藏实现细节。</li><li><strong>继承（Inheritance）</strong>：一个类可以继承另一个类的属性和方法，促进代码重用。</li><li><strong>多态（Polymorphism）</strong>：对象可以用多种形式存在，允许不同对象以相同接口调用。</li></ol><h4 id="为什么叫面向对象">为什么叫“面向对象”</h4><p>“面向对象”这个词反映了这种编程方法的核心：以对象为中心。程序中的所有东西都是对象，或者与对象相关。对象代表了程序中的实体，类定义了这些实体的结构和行为。</p><h5 id="面向对象-vs-面向过程">面向对象 vs 面向过程</h5><ul><li><strong>面向过程编程（Procedural Programming）</strong>：将程序视为一系列步骤或过程（函数）的集合。程序的焦点在于函数和过程的调用顺序。</li><li><strong>面向对象编程（Object-Oriented Programming）</strong>：将程序视为对象的集合。程序的焦点在于对象及其交互。</li></ul><h5 id="面向对象的本质和内涵">面向对象的本质和内涵</h5><ul><li><strong>模拟现实</strong>：通过对象和类模拟现实世界中的实体和关系。</li><li><strong>组织代码</strong>：通过类和对象组织代码，使其更具可读性和可维护性。</li><li><strong>封装和抽象</strong>：隐藏实现细节，只暴露必要的接口。</li><li><strong>复用性和可扩展性</strong>：通过继承和多态实现代码复用和扩展。</li></ul><h5 id="对象的真实含义">对象的真实含义</h5><p>在OOP中，对象是程序中的基本单元，包含了属性和方法：</p><ul><li><strong>属性（Attributes）</strong>：对象的状态或数据。</li><li><strong>方法（Methods）</strong>：对象的行为或功能。</li></ul><p>例如，一个“Person”对象可能有“name”和“age”属性，以及“greet”方法。</p><h5 id="计算属性">计算属性</h5><p>**计算属性是类或结构体中的属性，但它们的值不是直接存储的，而是通过计算得来的。**计算属性本质上是getter和setter函数：</p><ul><li><strong>Getter</strong>：返回计算属性的值。</li><li><strong>Setter</strong>：设置计算属性的值。</li></ul><h4 id="为什么属性可以作为函数">为什么属性可以作为函数</h4><p>计算属性之所以可以作为函数，是因为它们通过getter和setter函数计算和设置值。这样，属性的值可以根据其他属性动态计算，而不需要显式存储。</p><h4 id="示例：计算属性">示例：计算属性</h4><pre><code class="language-swift">class Circle {
    var radius: Double

    var circumference: Double {
        get {
            return 2 * .pi * radius
        }
        set {
            radius = newValue / (2 * .pi)
        }
    }

    init(radius: Double) {
        self.radius = radius
    }
}

let circle = Circle(radius: 5)
print(circle.circumference) // 输出 31.4159

circle.circumference = 31.4159
print(circle.radius) // 输出 5
</code></pre><p>在这个示例中，<code>circumference</code> 是一个计算属性，通过getter和setter函数计算和设置圆的周长和半径。</p></div><footer class="post__footer"><div class="post__last-updated">This article was updated on <time datetime="2024-07-21T00:34">Jul 21, 2024</time></div><div class="post__share"><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fscooorpion.github.io%2Fswift-notes.html&amp;via=FX&amp;text=Swift%20Notes" class="js-share twitter tltp tltp--top" aria-label="Twitter" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://scooorpion.github.io/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span> </a><a href="https://pinterest.com/pin/create/button/?url=https%3A%2F%2Fscooorpion.github.io%2Fswift-notes.html&amp;media=https%3A%2F%2Fscooorpion.github.io%2Fmedia%2Fposts%2F20%2Fgoogle-deepmind-RO_I_35SX7c-unsplash.jpg&amp;description=Swift%20Notes" class="js-share pinterest tltp tltp--top" aria-label="Pinterest" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://scooorpion.github.io/assets/svg/svg-map.svg#pinterest"/></svg> <span>Pinterest</span></a></div></footer></div></article><div class="post__section post__comments"><div class="main__inner"></div></div></main></div><script defer="defer" src="https://scooorpion.github.io/assets/js/scripts.min.js?v=12d8fcd46db8fdc7af6797ec26849875"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://scooorpion.github.io/assets/js/quicklink.umd.js?v=a52ee49fe4afff274f8c30fe880ddc13"></script><script>window.addEventListener('load', () =>{
      quicklink.listen();
      });</script><script defer="defer" src="https://scooorpion.github.io/media/plugins/syntaxHighlighter/prism.js"></script></body></html>